!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).ceval=t()}(this,(function(){"use strict";class e{constructor(e,t){this.type=e,this.value=null!=t?t:0}}const t="TOKEN_END",s="TOKEN_COMMA",r="TOKEN_NAME",n="TOKEN_SEMICOLON";class i{constructor(e,t,s){this.type=e,this.value=t,this.index=s,this.toString=()=>this.type+": "+this.value,this.toString=this.toString.bind(this)}}const{toString:o}=Object.prototype;function a(e){return"[object Object]"===o.call(e)}function h(e,t){return a(e)?Object.prototype.hasOwnProperty.call(e,t):Array.isArray(e)?e.some(e=>e===t):e.indexOf(t)>-1}function c(e,t){return Object.keys(t).forEach(s=>{const r=t[s];Object.prototype.hasOwnProperty.call(e,s)||(Array.isArray(r)?c(e[s]=[],r):a(r)?c(e[s]={},r):e[s]=r)}),e}function p(...e){let t;return e.some(e=>!h([void 0,null,!0,!1],e)&&(t=e,!0)),t}function u(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function l(t,s){if("string"==typeof t[0]&&t.length!==function(e){const t=[];return e.forEach(e=>{-1===t.indexOf(e)&&t.push(t)}),t}(t).length)throw new Error("Duplicate parameter: "+t.join(","));const r=Object.create(null);return t.forEach(t=>{let n;n=t instanceof e?t.value:t,r[n]="function"==typeof s?s(n):s}),r}function d(...e){const t=e.pop();if(!e.find(e=>!!e))throw new Error(t)}function E(e,t,s){if(e.length<2)return u(t,e[0])?t[e[0]]:s[e[0]];let r=e.shift();const n=e.pop();let i=u(t,r)?t:s;for(;r;){if(u(i,r))i=i[r];else{if(!i)throw new TypeError(`Uncaught TypeError: Cannot read property '${r}' of ${i}`);i=void 0}r=e.shift()}return new f(i,n)}class f{constructor(e,t){this.target=e,this.path=t,this.destoryed=!1}setValue(e){return this.destoryed?e:this.target[this.path]=e}getValue(){if(!this.destoryed)return this.target[this.path]}destory(){this.destoryed=!0,this.target=null}}function O(e){return(e.toString().split(".")[1]||"").length}function N(e){return e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER}function T(e,t){const s=Math.pow(10,Math.max(O(e),O(t)));return N(e*s)||N(t*s)?0:s}const x=(e,t)=>Number.isInteger(e)&&Number.isInteger(t)||"number"!=typeof e||"number"!=typeof t;const w={functions:{random:function(e){return Math.random()*(e||1)},min:function(...e){return e.length,Math.min.apply(Math,e)},max:function(...e){return e.length,Math.max.apply(Math,e)},map:function(e,t){if("function"!=typeof e)throw new Error("First argument is not a function");if(!Array.isArray(t))throw new Error("Second argument is not an array");return t.map((function(t,s){return e(t,s)}))},pow:Math.pow},consts:{E:Math.E,PI:Math.PI,true:!0,false:!1,undefined:void 0,null:null,NaN:Number.NaN,Infinity:1/0,Map:Object.create(null)},binaryOps:{"+":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e+t;const r=T(e,t);return 0===r?e+t:(Math.round(e*r)+Math.round(t*r))/r},"-":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e-t;const r=T(e,t);return 0===r?e-t:(Math.round(e*r)-Math.round(t*r))/r},"*":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e*t;const r=T(e,t);return 0===r?e*t:Math.round(e*r)*Math.round(t*r)/Math.pow(r,2)},"/":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e/t;const r=T(e,t);return 0===r?e/t:Math.round(e*r)/Math.round(t*r)},"%":function(e,t){return e%t},"^":function(e,t){return e^t},"||":function(e,t){return e||t},"&&":function(e,t){return e?t:e},"==":function(e,t){return e==t},"!=":function(e,t){return e!=t},"!==":function(e,t){return e!==t},">":function(e,t){return e>t},"<":function(e,t){return e<t},">=":function(e,t){return e>=t},"<=":function(e,t){return e<=t},"=":function(e,t,s){return s&&(s[e]=t),t},"[":function(e,t){return e[0|t]},"===":function(e,t){return e===t},in:function(e,t){if("object"!=typeof t||String(e)!==""+e)throw new Error("first argument must be original type, second must be Array or Object");return a(t)?Object.prototype.hasOwnProperty.call(t,function e(t){const s=/^\"(.*)\"$|^\'(.*)\'$/;if(!s.test(t))return t;const r=s.exec(t);return e(void 0!==r[1]?r[1]:r[2])}(e)):h(t,e)}},ternaryOps:{"?":function(e,t,s){return e?t:s}},unaryOps:{"+":e=>+e,"-":e=>-e,"!":e=>!e,"~":e=>~e,"++":e=>e+1,"--":e=>e-1,typeof:e=>{return t=e,Object.prototype.toString.call(t).match(/^\[object\s*(\w+?)\]$/)[1].toLowerCase();var t},return:e=>e,sin:Math.sin,cos:Math.cos,tan:Math.tan},syntaxOperator:{":":null,".":null}};Object.defineProperty(w.consts,"Map",{get:()=>Object.create(null)});const b=["=","["],y=Object.assign(function e(t,s,r){return Object.keys(s).map(n=>a(s[n])?e(t,s[n],r):r(t,n,s[n])),t}(Object.create(null),{binaryOps:w.binaryOps,unaryOps:w.unaryOps,ternaryOps:w.ternaryOps},(e,t,s)=>{b.includes(t)||(e[t]=s)}),{functions:w.functions,consts:w.consts}),g=[],v=Array.from(new Set([].concat(Object.keys(w.unaryOps).filter(e=>!/\b\w+\b/.test(e)),Object.keys(w.binaryOps),Object.keys(w.ternaryOps),Object.keys(w.syntaxOperator)).filter(e=>!h(g,e)).sort((e,t)=>t.length-e.length))),m=/(\t|\n|\r|\s+)/,_=/^(false|true)/,S=/^\/\*(.*?)\*\//,R=/^\'(.*?)\'|^\"(.*?)\"/,A=/^\'(.*)\'|^\"(.*)\"/,P=/^(0b[0|1]{1,})$/,I=/^(0[0-7]{1,})$/,C=/^(0\d*[8-9]{1,}\d*(\.\d+)?)$/,k=/(^([1-9]\d*(\.\d+)|(\d*(\.\d+)?)))/,K=/^(0x[0-9a-fA-F]{1,})$/,M=/^((\d*\.?\d*)[e|E]((\-|\+)?\d+))/,j=/^((_|$)?[0-9a-zA-Z|$|_]{1,})/,U=new RegExp(`^(${v.map(e=>`(\\${/\b\w+\b/.test(e)?e+"\\s+":e.split("").join("\\")})`).join("|")})`),$=new RegExp(`^(${Object.keys(w.unaryOps).filter(e=>/\b\w+\b/.test(e)).join("|")})`),F=new RegExp(`^(${Object.keys(w.unaryOps).filter(e=>!/\b\w+\b/.test(e)).map(e=>`\\s*\\${e}\\s*`).join("|")})`),B=new RegExp(`^(${Object.keys(w.consts).map(e=>""+e).join("|")})`),L=(e,t,s=(e=>e))=>{e.lastIndex=0;const r=e.exec(t);return null===r||""===r[0]?s(void 0):s(r[1])},D=({value:e})=>Object.prototype.hasOwnProperty.call(w.unaryOps,e);let V=(()=>{class i{constructor(i,o,a){this.ceval=i,this.tokens=o,this.current=null,this.savedCurrent=null,this.nextToken=null,this.savedNextToken=null,this.inspectParseEnd=e=>{const s=this.tokens.expression.length;do{this.parseExpression(e)}while(this.current.index<s&&this.nextToken.type!==t)},this.next=()=>(this.current=this.nextToken,this.nextToken=this.tokens.next()),this.matchToken=e=>void 0===e||(Array.isArray(e)?-1!==e.indexOf(this.nextToken.value):"function"==typeof e?e(this.nextToken):("string"==typeof e||"number"==typeof e)&&e===this.nextToken.value),this.accept=(e,t,s=!0)=>!(!this.nextToken||this.nextToken.type!==e||!this.matchToken(t))&&(s&&this.next(),!0),this.expect=(e,s)=>{if(this.accept(e,s))return!0;{const{line:e,column:r}=this.tokens.getCoordinates();throw this.printLog(`> line:${e} column:${r-1} "${this.current.value}"\nThe next tag should be "${s}", But the reality is`,""+(this.nextToken.type===t?"empty content":`"${this.nextToken.value}"`),console.error),new Error("Unexpected Tag")}},this.temporarySaved=()=>{this.savedCurrent=this.current,this.savedNextToken=this.nextToken,this.tokens.temporarySaved()},this.restore=()=>{this.current=this.savedCurrent,this.nextToken=this.savedNextToken,this.tokens.restore()},this.parseExpression=e=>{const t=[];this.parseMultipleEvaluation(t),t.forEach(t=>e.push(t))},this.parseMultipleEvaluation=e=>{for(this.parseAssignmentExpression(e);this.accept(s,",");)this.parseConditionalExpression(e)},this.parseAssignmentExpression=t=>{for(this.parseConditionalExpression(t);this.accept("TOKEN_OP","=");){let s;"INSTR_VAR"===t[t.length-1].type&&(s=t.pop());const r=[];this.parseConditionalExpression(r),t.push(new e("INSTR_EXPRE",r)),s?t.push(s):t.push(new e("INSTR_OP2","="))}},this.parseConditionalExpression=t=>{for(this.parseOrExpression(t);this.accept("TOKEN_OP","?");){const s=[],r=[];this.parseConditionalExpression(s),this.expect("TOKEN_OP",":"),this.parseConditionalExpression(r),t.push(new e("INSTR_EXPRE",s)),t.push(new e("INSTR_EXPRE",r)),t.push(new e("INSTR_OP3","?"))}},this.parseOrExpression=t=>{for(this.parseAndExpression(t);this.accept("TOKEN_OP","||");){var s=[];this.parseAndExpression(s),t.push(new e("INSTR_EXPRE",s)),t.push(new e("INSTR_OP2","||"))}},this.parseAndExpression=t=>{for(this.parseBitwiseOrExpression(t);this.accept("TOKEN_OP","&&");){var s=[];this.parseBitwiseOrExpression(s),t.push(new e("INSTR_EXPRE",s)),t.push(new e("INSTR_OP2","&&"))}},this.parseBitwiseOrExpression=t=>{for(this.parseBitwiseAndExpression(t);this.accept("TOKEN_OP","^");)this.parseBitwiseAndExpression(t),t.push(new e("INSTR_OP2","^"))},this.parseBitwiseAndExpression=t=>{for(this.parseEqualExpression(t);this.accept("TOKEN_OP","&");)this.parseBitwiseAndExpression(t),t.push(new e("INSTR_OP2","&"))},this.parseEqualExpression=t=>{for(this.parseCompareExpression(t);this.accept("TOKEN_OP",["==","===","!=","!=="]);){var s=this.current;this.parseCompareExpression(t),t.push(new e("INSTR_OP2",s.value))}},this.parseCompareExpression=t=>{for(this.parseInOrAtExpression(t);this.accept("TOKEN_OP",["<","<=",">=",">"]);){var s=this.current;this.parseInOrAtExpression(t),t.push(new e("INSTR_OP2",s.value))}},this.parseInOrAtExpression=t=>{for(this.parseBitwiseMoveExpression(t);this.accept("TOKEN_OP",["in"]);){var s=this.current;this.parseBitwiseMoveExpression(t),t.push(new e("INSTR_OP2",s.value))}},this.parseBitwiseMoveExpression=t=>{for(this.parseAddOrSubExpression(t);this.accept("TOKEN_OP",[">>",">>>","<<"]);){var s=this.current;this.parseAddOrSubExpression(t),t.push(new e("INSTR_OP2",s.value))}},this.parseAddOrSubExpression=t=>{for(this.parseMulOrDivExpression(t);this.accept("TOKEN_OP",["+","-"]);){var s=this.current;this.parseMulOrDivExpression(t),t.push(new e("INSTR_OP2",s.value))}},this.parseMulOrDivExpression=t=>{for(this.parseUnaryExpression(t);this.accept("TOKEN_OP",["*","/","%"]);){var s=this.current;this.parseUnaryExpression(t),t.push(new e("INSTR_OP2",s.value))}},this.parseUnaryExpression=r=>{if(this.temporarySaved(),this.accept("TOKEN_OP",D))if(F.test(this.current.value)){const t=this.current;this.parseUnaryExpression(r),r.push(new e("INSTR_OP1",t.value))}else if(this.accept("TOKEN_PAREN","(",!1)){const t=this.current;this.accept("TOKEN_PAREN","("),this.parseConditionalExpression(r),this.expect("TOKEN_PAREN",")"),r.push(new e("INSTR_OP1",t.value))}else if(-1!==[s,n,t].indexOf(this.nextToken.type)||"TOKEN_PAREN"===this.nextToken.type&&")"===this.nextToken.value)this.restore(),this.parseField(r);else{const t=this.current;this.parseUnaryExpression(r),r.push(new e("INSTR_OP1",t.value))}else this.parseOuterFunctionCallExpression(r)},this.parseOuterFunctionCallExpression=e=>{this.parseMemberAccessExpression(e),this.current.type===r&&this.accept("TOKEN_PAREN","(",!1)&&this.parseArguments(e)},this.parseArguments=t=>{for(;this.accept("TOKEN_PAREN","(");)if(this.accept("TOKEN_PAREN",")"))t.push(new e("INSTR_FUNCALL",0));else{let r=0;for(;!this.accept("TOKEN_PAREN",")");)do{this.parseConditionalExpression(t),r++}while(this.accept(s));t.push(new e("INSTR_FUNCALL",r))}},this.parseMemberAccessExpression=t=>{this.parseField(t);const s=[],n=t[t.length-1];for(n&&"INSTR_NAME"===n.type&&s.push(n.value);this.accept("TOKEN_OP",".")||h(["TOKEN_SQUARE",r],this.current.type)&&this.accept("TOKEN_SQUARE","[");){if(!this.ceval.getOptions().allowMemberAccess)throw new Error('options "allowMemberAccess": You have disabled member access and cannot use syntax such as "a.b" "a[\'b\']"');"."===this.current.value?(this.expect(r),s.push(new e("INSTR_PLAIN",this.current.value))):"["===this.current.value&&(this.accept(r)||this.accept("TOKEN_NUMBER")||this.accept("TOKEN_STRING"))&&(s.push(new e(this.current.type===r?"INSTR_NAME":"INSTR_PLAIN",this.current.value)),this.expect("TOKEN_SQUARE","]"))}s.length>1&&(t.pop(),t.push(new e("INSTR_MEMBER",s)))},this.parseField=t=>{if(this.accept("TOKEN_OP",D))t.push(new e("INSTR_OP1",this.current.value));else if(this.accept(r))this.accept("TOKEN_OP","=",!1)?t.push(new e("INSTR_VARNAME",this.current.value)):t.push(new e("INSTR_NAME",this.current.value));else if(this.accept("TOKEN_NUMBER"))t.push(new e("INSTR_NUMBER",this.current.value));else if(this.accept("TOKEN_STRING"))t.push(new e("INSTR_PLAIN",this.current.value));else if(this.accept("TOKEN_PAREN","("))this.parseExpression(t),this.expect("TOKEN_PAREN",")");else if(this.accept("TOKEN_SQUARE","["))this.parseArrayLiteralDeclaration(t);else if(this.accept("TOKEN_CURLY","{",!1))this.parseObjectLiteralDeclaration(t);else if(this.accept("TOKEN_VAR",["const","var","let"])){const s=this.current;this.expect(r),t.push(new e("INSTR_VARNAME",this.current.value)),t.push(new e("INSTR_VAR",s.value))}else if(this.accept("TOKEN_FUNC",void 0,!1))this.parseFunctionDefinedDeclaration(t);else if(!this.accept(n))throw new Error("unexpected "+this.nextToken)},this.parseArrayLiteralDeclaration=t=>{const s=[];this.accept("TOKEN_SQUARE","]")||(this.parseExpression(s),this.expect("TOKEN_SQUARE","]")),t.push(new e("INSTR_ARRAY",s))},this.parseObjectLiteralDeclaration=t=>{for(;this.accept("TOKEN_CURLY","{");){const i={};if(this.accept("TOKEN_CURLY","}"))return void t.push(new e("INSTR_OBJECT",i));for(;this.accept(r)||this.accept("TOKEN_NUMBER")||this.accept("TOKEN_STRING");){const e=this.current.value;this.expect("TOKEN_OP",":"),i[e]=[],this.accept("TOKEN_CURLY","{",!1)?this.parseObjectLiteralDeclaration(i[e]):this.parseConditionalExpression(i[e]),this.accept(s,",")}this.expect("TOKEN_CURLY","}"),this.accept(n,";"),t.push(new e("INSTR_OBJECT",i))}},this.parseFunctionDefinedDeclaration=t=>{for(;this.accept("TOKEN_FUNC");)if(this.accept(r)){const r=this.current.value,n=[];if(this.accept("TOKEN_PAREN","(")){do{this.parseField(n)}while(this.accept(s));this.expect("TOKEN_PAREN",")")}this.parseFunctionBodyExpression(n),t.push(new e("INSTR_FUNCDEF",n)),t.push(new e("INSTR_FUNCDEF",r))}},this.parseFunctionBodyExpression=t=>{if(this.accept("TOKEN_CURLY","{")){const s=[];do{this.parseExpression(s)}while(this.accept(n,";")&&!this.accept("TOKEN_CURLY","}",!1));if(this.current.type!==n)throw new SyntaxError("Function parse error: Function body each line must end with semicolon ';'");this.expect("TOKEN_CURLY","}"),this.accept(n,";"),t.push(new e("INSTR_EXPRE",s))}},this.printLog=(e,t,s=console.log)=>{s(`${e} %c${t}`,"margin: 0 .5em;text-decoration-line: underline;text-decoration-color: red;text-decoration-style: wavy;line-height: 2em;color: red;")},this.next(),this.inspectParseEnd(a)}}return i.generatorParser=(e,t,s)=>new i(e,t,s),i})();const Y={abstract:!1,arguments:!1,boolean:!1,break:!1,byte:!1,case:!1,catch:!1,char:!1,class:!1,const:!1,continue:!1,debugger:!1,default:!1,delete:!1,do:!1,double:!1,else:!1,enum:!1,eval:!1,export:!1,extends:!1,final:!1,finally:!1,float:!1,for:!1,function:!1,goto:!1,if:!1,implements:!1,import:!1,in:!0,instanceof:!1,int:!1,interface:!1,let:!1,long:!1,native:!1,new:!1,null:!1,package:!1,private:!1,protected:!1,public:!1,return:!0,short:!1,static:!1,super:!1,switch:!1,synchronized:!1,this:!1,throw:!1,throws:!1,transient:!1,try:!1,typeof:!1,var:!1,void:!1,volatile:!1,while:!1,with:!1,yield:!1},G={Array:!1,Date:!1,eval:!1,function:!1,hasOwnProperty:!1,Infinity:!1,isFinite:!1,isNaN:!1,isPrototypeOf:!1,length:!1,Math:!1,NaN:!0,name:!1,Number:!1,Object:!1,prototype:!1,String:!1,toString:!1,undefined:!1,valueOf:!1};class X{constructor(e,o){this.ceval=e,this.expression=o,this.pos=0,this.current=null,this.savedPosition=0,this.savedCurrent=null,this.checkNextAccessGrammar=()=>{this.temporarySaved();const e=this.next();return this.restore(),e},this.getSomeCode=(e=1,t=0)=>{const s=t+this.pos,{length:r}=this.expression;return this.expression.substr(s,s+e>r?r-s:e)},this.getFirstWord=()=>{const e=this.expression.substr(this.pos).match(/\b\w*\b/);return e?e[0]:""},this.newToken=(e,t,s)=>new i(e,t,null!=s?s:this.pos),this.next=()=>this.expression.length?this.pos>=this.expression.length?this.newToken(t,"END"):this.isWhiteSpace()||this.isComment()?this.next():this.isNumber()||this.isString()||this.isBoolean()||this.isParenthesis()||this.isComma()||this.isOperator()||this.isSemicolon()||this.isConst()||this.isVariable()||this.isFunctionDefined()||this.isName()?this.current:void this.parseError("unknown character: "+this.expression.charAt(this.pos),SyntaxError):this.newToken(r,"undefined"),this.temporarySaved=()=>{this.savedPosition=this.pos,this.savedCurrent=this.current},this.restore=()=>{this.pos=this.savedPosition,this.current=this.savedCurrent},this.isWhiteSpace=()=>{const e=m.exec(this.getSomeCode());for(;e&&e[1];)return this.pos++,!0;return!1},this.isComment=()=>{const e=this.getSomeCode(2);let t;return"/*"===e?t=L(S,this.getSomeCode(1/0)):"//"===e&&(t=L(/^(\/\/.*\n?)/,this.getSomeCode(1/0))),!!t&&(this.pos+=t.length+("/*"===e?4:0),!0)},this.isBoolean=()=>{const e=_.exec(this.getSomeCode());for(;e&&e[1];)return this.pos++,!0;return!1},this.isVariable=()=>{const e=this.getFirstWord();if(h(["const","var","let"],e)){this.pos+=e.length,this.current=this.newToken("TOKEN_VAR",e);const t=this.checkNextAccessGrammar();if(t.type!==r)throw new Error(`${e} ${t.value} : This syntax Not as expected, should be "${r}", but is "${t}"`);if(h(this.ceval.consts,t.value))throw new SyntaxError(`SyntaxError:  Unexpected token '${t.value}', it has been stated in consts.`);return!0}return!1},this.isNumber=()=>{const e=this.getSomeCode();let t,s;const r=this.getSomeCode(this.expression.length-this.pos);if(!1===/\d|\./.test(e)||"."===e&&!1===/\.\d/.test(this.getSomeCode(2)))return!1;const[n]=r.match(/^(0(x|b)+[0-9a-zA-Z]{1,})|(^0?\d*(\.\d+)?)/);if(k.lastIndex=0,"0"===e&&n.length>1&&!/^0\.\d/.test(n)){if(h(["b","x"],this.getSomeCode(1,1))&&"."===this.getSomeCode(1,n.length))return this.parseError(`number '${n}' cannot is a floating point number, but actual is: '${n}${this.getSomeCode(3,n.length)}'`,SyntaxError),!1;if(P.test(n))t=L(P,n),s=void 0===t?void 0:2;else if(I.test(n))t=L(I,n),s=void 0===t?void 0:8;else if(K.test(n))t=L(K,n),s=void 0===t?void 0:16;else{if(!C.test(n))return this.parseError("number bitbase parser error",SyntaxError),!1;t=L(C,n),s=void 0===t?void 0:10}if(this.pos+=t.length,void 0!==t&&!this.ceval.getOptions().endableBitNumber)throw new Error('options "endableBitNumber": You have disabled bitbase number parsing, Not allowed '+t)}else if(M.test(r)){M.lastIndex=0;const[,e,n,i]=M.exec(r);this.pos+=e.length||n.length+i.length+1,t=e||(Number(n)*Math.pow(10,Number(i))).toString(),s=10}else{if(!k.test(r))return!1;t=L(k,r),s=void 0===t?void 0:10,this.pos+=t.length}return this.current=10===s?this.newToken("TOKEN_NUMBER",parseFloat(t)):this.newToken("TOKEN_NUMBER",parseInt(t.replace("0b","").replace("0x",""),s)),!0},this.isString=()=>{const e=this.getSomeCode(),t=this.getSomeCode(1/0);let s,r;return('"'===e||"'"===e)&&(A.lastIndex=0,s=A.exec(t),r=p(s[1],s[2]),function(e){let t=0;for(;h(["'",'"'],e.charAt(t))&&e.charAt(t)===e.charAt(e.length-1-t);)t++;const s=e.substring(t,e.length-t);return-1===s.indexOf('"')&&-1===s.indexOf("'")}(r)||(R.lastIndex=0,s=R.exec(t),r=p(s[1],s[2])),void 0!==r)&&(this.current=this.newToken("TOKEN_STRING",r,this.pos),this.pos+=r.length+2*e.length,!0)},this.isFunctionDefined=()=>{const e=this.getFirstWord();if("function"===e){this.current=this.newToken("TOKEN_FUNC",void 0),this.pos+=e.length;return this.checkNextAccessGrammar().type===r||(this.parseError("function definition should have function name"),!1)}return!1},this.isName=()=>{const e=this.getSomeCode();let t;return("_"===e||"$"===e||/^[a-zA-Z]/.test(e))&&(j.lastIndex=0,t=j.exec(this.getSomeCode(1/0))),null!=t&&"string"==typeof t[1]&&([,t]=t,!1===Y[t]?(this.parseError("parser an reserved word: "+t),!1):!1===G[t]?(this.parseError("parser an window native attributes or methods: "+t),!1):(this.pos+=t.length,this.current=this.newToken(r,t),!0))},this.isConst=()=>{B.lastIndex=0;const e=B.exec(this.getSomeCode(1/0));if(e&&e[1]){this.current=this.newToken(r,e[1]),this.pos+=e[1].length;const t=this.checkNextAccessGrammar();return"TOKEN_OP"===t.type&&"="===t.value&&this.parseError(`parser error: consts of ${this.current.value} can not assignment;`,SyntaxError),!0}return!1},this.isSemicolon=()=>";"===this.getSomeCode()&&(this.current=this.newToken(n,";"),this.pos++,!0),this.isComma=()=>","===this.getSomeCode()&&(this.current=this.newToken(s,","),this.pos++,!0),this.isParenthesis=()=>{var e=this.getSomeCode();if(h(["(",")"],e))this.current=this.newToken("TOKEN_PAREN",e);else if(h(["[","]"],e))this.current=this.newToken("TOKEN_SQUARE",e);else{if(!h(["{","}"],e))return!1;this.current=this.newToken("TOKEN_CURLY",e)}return this.pos++,!0},this.isOperator=()=>{const e=this.getSomeCode(1/0);let t;if(U.test(e)?t=L(U,e):$.test(e)&&(t=L($,e)),!t)return!1;if(!1===this.ceval.getOptions().endableOperators)throw new Error(`options "endableOperators": You disabled the operator, Therefore, "${t}" it can not be used`);return t=t.replace(/\s/g,""),this.pos+=t.length,this.current=this.newToken("TOKEN_OP",t),!0},this.getCoordinates=()=>{let e=0,t=0,s=-1;do{e++,t=this.pos-s,s+=1,s+=this.expression.substr(s).indexOf("\n")}while(s>=0&&s<this.pos&&e<this.pos);return{line:e,column:t}},this.parseError=(e,t=Error)=>{var s=this.getCoordinates();throw new t("parse error ["+s.line+":"+s.column+"] => "+e)}}}function Q(t,s=Object.create(null),r,n=!1,i=Object.create(null)){const o=r.getOptions(),{unaryOps:a,binaryOps:h,ternaryOps:p}=r,l=[],{length:O}=t;let N,T,x,w;for(let b=0;b<O;b++){const y=t[b],{type:g,value:v}=y||{};if(g)switch(g){case"INSTR_NUMBER":case"INSTR_PLAIN":case"INSTR_VARNAME":l.push(v);break;case"INSTR_NAME":if(u(i,v))l.push(i[v]);else if(u(s,v))l.push(s[v]);else if(u(r.consts,v))l.push(r.consts[v]);else{if(!u(r.functions,v))throw new Error(v+" is not defined in values or consts");l.push(r.functions[v])}break;case"INSTR_OP1":if(0===l.length)break;[N]=l.splice(-1,1),w=H(v,[s,a],o.allowOperatorsCovered),l.push(w(N)),"return"===v&&(b=O);break;case"INSTR_OP2":if(l.length<2)break;[N,T]=l.splice(-2,2),w=H(v,[s,h],o.allowOperatorsCovered),"&&"===v?l.push(w(N,Q([T],s,r,n,i),!1)):"="===v?N instanceof f?(N.setValue(T),N.destory()):(d(u(i,N),u(s,N),N+" is not define in values or current scope, if you are declaring a new variable, please add var, const or let operator"),w(N,T,u(i,N)?i:s)):l.push(w(N,"string"==typeof T||"number"==typeof T?T:Q([T],s,r,n,i),o));break;case"INSTR_OP3":if(l.length<3)break;[N,T,x]=l.splice(-3,3),w=H(v,[s,p],o.allowOperatorsCovered),l.push(w(N,T,x));break;case"INSTR_EXPRE":l.push(Q(y.value,s,r,n,i));break;case"INSTR_MEMBER":{const e=t[b+2],n=E(Q(v,s,r,!0,i),i,s);e&&"INSTR_OP2"===e.type&&"="===e.value?l.push(n):(l.push(n.getValue()),n.destory());break}case"INSTR_ARRAY":l.push(Q(v,s,r,!0,i));break;case"INSTR_OBJECT":{const e=Object.create(null);Object.keys(v).forEach(t=>{e[t]=Q(v[t],s,r,n,i)}),l.push(e);break}case"INSTR_VAR":switch([N,T]=l.splice(-2,2),v){case"let":case"const":u(i,N)&&console.warn(N+" already statement in consts or scope"),i[N]=T;break;case"var":s[N]=T;break;default:console.warn("Unexpected statement identifier")}break;case"INSTR_FUNCALL":{const e=l.splice(-v,v);if(w=l.pop(),"function"==typeof w){l.push(w.apply(null,e));continue}w.value instanceof W&&(w.value.updateScope(e),l.push(w.value.invokeBody()));break}case"INSTR_FUNCDEF":{if("string"!=typeof v){l.push(v);continue}if(0===l.length)return;const t=c(Object.create(null),i);t[v]=new e("INSTR_EXECUTBODY",new W(l.pop(),s,t,r)),Object.assign(i,t);break}default:{const e=Symbol("_init");let t=e;try{t=y.value}catch(e){}t!==e&&l.push(t)}}else l.push(y)}return n?l:l[0]}function H(e,[t,s],r=!1){let n;return n=r&&u(t,e)?t[e]:s[e],n}class W{constructor(e,t,s,r){this.func=e,this.values=t,this._scope=s,this.ceval=r,this.updateScope=e=>{this.args.forEach((t,s)=>{u(this._scope,t)&&(this._scope[t]=e[s])})},this.invokeBody=()=>Q(this.func,this.values,this.ceval,!1,this._scope);const n=this.func.splice(0,e.length-1);this.args=Q(n,l(n,e=>e),r,!0),this._scope=c(l(n),s)}}const[z,J]=function(e=0){const t=new Date(Date.now()+e);return[`${t.getFullYear()}-${t.getMonth()+1}-${t.getDate()}`,`${t.getHours()}:${t.getMinutes()}:${t.getSeconds()}`.replace(/\d+/g,e=>parseInt(e,10)<10?"0"+e:e)]}();var Z={now:Date.now(),date:z,time:J};class q{constructor(){this.endableOperators=!0,this.endableBitNumber=!0,this.allowMemberAccess=!0,this.allowHandleNumberPrecision=!0,this.allowOperatorsCovered=!1,this.defaultReturnValues=""}}return class{constructor(e={}){this.options=e,this.operatorMap=y,this.currentValues={...Z},this.getSupportOperationMap=e=>Object.prototype.hasOwnProperty.call(y,e)?y[e]:null,this.parseString=(e,t={})=>{const s=[];let r;if("development"!==process.env.NODE_ENV)V.generatorParser(this,new X(this,e),s),r=this.injectValueToCalc(s,t);else try{V.generatorParser(this,new X(this,e),s),r=this.injectValueToCalc(s,t)}catch(e){console.error(e)}return r},this.getCurrentValues=()=>({...this.currentValues}),this.injectValueToCalc=(e,t={})=>{this.updatePresetValues(t);const s=Q(e,this.currentValues,this);return void 0===s?this.options.defaultReturnValues:s},this.updatePresetValues=e=>{Object.assign(this.currentValues,e)},this.updateOptions=e=>{Object.assign(this.options,e)},this.getOptions=()=>({...this.options}),Object.assign(this,w),console.log(y),c(this.options,new q)}}}));
//# sourceMappingURL=index.js.map
