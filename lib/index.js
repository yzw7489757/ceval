!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("lodash/cloneDeep")):"function"==typeof define&&define.amd?define(["lodash/cloneDeep"],t):(e=e||self).ceval=t(e.cloneDeep)}(this,(function(e){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e;class t{constructor(e,t){this.type=e,this.value=null!=t?t:0}}const s="TOKEN_END",r="TOKEN_COMMA",n="TOKEN_NAME",i="TOKEN_SEMICOLON";class o{constructor(e,t,s){this.type=e,this.value=t,this.index=s,this.toString=()=>this.type+": "+this.value,window._debug&&console.log(`type: ${e}; value: ${t}; index: ${s}`)}}const{toString:a}=Object.prototype;function h(e){return"[object Object]"===a.call(e)}function c(e,t){return h(e)?Object.prototype.hasOwnProperty.call(e,t):Array.isArray(e)?e.some(e=>e===t):e.indexOf(t)>-1}function p(e,t){return Object.keys(t).forEach(s=>{const r=t[s];Object.prototype.hasOwnProperty.call(e,s)||(Array.isArray(r)?p(e[s]=[],r):h(r)?p(e[s]={},r):e[s]=r)}),e}function u(...e){let t;return e.some(e=>!c([void 0,null,!0,!1],e)&&(t=e,!0)),t}function l(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function d(e,s){if("string"==typeof e[0]&&e.length!==[...new Set(e)].length)throw new Error("Duplicate parameter: "+e.join(","));const r=Object.create(null);return e.forEach(e=>{let n;n=e instanceof t?e.value:e,r[n]="function"==typeof s?s(n):s}),r}function E(...e){const t=e.pop();if(!e.find(e=>!!e))throw new Error(t)}function f(e,t,s){if(e.length<2)return l(t,e[0])?t[e[0]]:s[e[0]];let r=e.shift();const n=e.pop();let i=l(t,r)?t:s;for(;r;){if(l(i,r))i=i[r];else{if(!i)throw new TypeError(`Uncaught TypeError: Cannot read property '${r}' of ${i}`);i=void 0}r=e.shift()}return console.log("target: ",i,n),new O(i,n)}class O{constructor(e,t){this.target=e,this.path=t,this.destoryed=!1}setValue(e){return this.destoryed?e:this.target[this.path]=e}getValue(){if(!this.destoryed)return this.target[this.path]}destory(){this.destoryed=!0,this.target=null}}function N(e){return(e.toString().split(".")[1]||"").length}function T(e){return e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER}function w(e,t){const s=Math.pow(10,Math.max(N(e),N(t)));return T(e*s)||T(t*s)?0:s}const x=(e,t)=>Number.isInteger(e)&&Number.isInteger(t)||"number"!=typeof e||"number"!=typeof t;const g={functions:{random:function(e){return Math.random()*(e||1)},min:function(...e){return e.length,Math.min.apply(Math,e)},max:function(...e){return e.length,Math.max.apply(Math,e)},map:function(e,t){if("function"!=typeof e)throw new Error("First argument is not a function");if(!Array.isArray(t))throw new Error("Second argument is not an array");return t.map((function(t,s){return e(t,s)}))},pow:Math.pow},consts:{E:Math.E,PI:Math.PI,true:!0,false:!1,undefined:void 0,null:null,NaN:Number.NaN,Infinity:1/0},binaryOps:{"+":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e+t;const r=w(e,t);return 0===r?e+t:(Math.round(e*r)+Math.round(t*r))/r},"-":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e-t;const r=w(e,t);return 0===r?e-t:(Math.round(e*r)-Math.round(t*r))/r},"*":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e*t;const r=w(e,t);return 0===r?e*t:Math.round(e*r)*Math.round(t*r)/Math.pow(r,2)},"/":function(e,t,s){if(!1===s.allowHandleNumberPrecision||x(e,t))return e/t;const r=w(e,t);return 0===r?e/t:Math.round(e*r)/Math.round(t*r)},"%":function(e,t){return e%t},"^":function(e,t){return e^t},"||":function(e,t){return e||t},"&&":function(e,t){return e?t:e},"==":function(e,t){return e==t},"!=":function(e,t){return e!=t},"!==":function(e,t){return e!==t},">":function(e,t){return e>t},"<":function(e,t){return e<t},">=":function(e,t){return e>=t},"<=":function(e,t){return e<=t},"=":function(e,t,s){return s&&(s[e]=t),t},"[":function(e,t){return e[0|t]},"===":function(e,t){return e===t},in:function(e,t){if("object"!=typeof t||String(e)!==""+e)throw new Error("first argument must be original type, second must be Array or Object");return h(t)?Object.prototype.hasOwnProperty.call(t,function e(t){const s=/^\"(.*)\"$|^\'(.*)\'$/;if(!s.test(t))return t;const r=s.exec(t);return e(void 0!==r[1]?r[1]:r[2])}(e)):c(t,e)}},ternaryOps:{"?":function(e,t,s){return e?t:s}},unaryOps:{"+":e=>+e,"-":e=>-e,"!":e=>!e,"~":e=>~e,"++":e=>e+1,"--":e=>e-1,typeof:e=>{return t=e,Object.prototype.toString.call(t).match(/^\[object\s*(\w+?)\]$/)[1].toLowerCase();var t},return:e=>e,sin:Math.sin,cos:Math.cos,tan:Math.tan},syntaxOperator:{":":null,".":null}},y=["=","["],v=function e(t,s,r){return Object.keys(s).map(n=>h(s[n])?e(t,s[n],r):r(t,n,s[n])),t}(Object.create(null),{functions:g.functions,consts:g.consts,unaryOps:g.unaryOps,ternaryOps:g.ternaryOps},(e,t,s)=>{y.includes(t)||(e[t]=s)}),b=[],m=Array.from(new Set([].concat(Object.keys(g.unaryOps).filter(e=>!/\b\w+\b/.test(e)),Object.keys(g.binaryOps),Object.keys(g.ternaryOps),Object.keys(g.syntaxOperator)).filter(e=>!c(b,e)).sort((e,t)=>t.length-e.length))),_=/(\t|\n|\r|\s+)/,S=/^(false|true)/,R=/^\/\*(.*?)\*\//,A=/^\'(.*?)\'|^\"(.*?)\"/,P=/^\'(.*)\'|^\"(.*)\"/,C=/^(0b[0|1]{1,})$/,k=/^(0[0-7]{1,})$/,I=/^(0\d*[8-9]{1,}\d*(\.\d+)?)$/,K=/(^([1-9]\d*(\.\d+)|(\d*(\.\d+)?)))/,M=/^(0x[0-9a-fA-F]{1,})$/,j=/^((\d*\.?\d*)[e|E]((\-|\+)?\d+))/,$=/^((_|$)?[0-9a-zA-Z|$|_]{1,})/,U=new RegExp(`^(${m.map(e=>`(\\${/\b\w+\b/.test(e)?e+"\\s+":e.split("").join("\\")})`).join("|")})`),F=new RegExp(`^(${Object.keys(g.unaryOps).filter(e=>/\b\w+\b/.test(e)).join("|")})`),B=new RegExp(`^(${Object.keys(g.unaryOps).filter(e=>!/\b\w+\b/.test(e)).map(e=>`\\s*\\${e}\\s*`).join("|")})`),D=new RegExp(`^(${Object.keys(g.consts).map(e=>""+e).join("|")})`),V=(e,t,s=(e=>e))=>{e.lastIndex=0;const r=e.exec(t);return null===r||""===r[0]?s(void 0):s(r[1])},L=({value:e})=>Object.prototype.hasOwnProperty.call(g.unaryOps,e);let Y=(()=>{class e{constructor(e,o,a){this.ceval=e,this.tokens=o,this.current=null,this.savedCurrent=null,this.nextToken=null,this.savedNextToken=null,this.inspectParseEnd=e=>{const t=this.tokens.expression.length;do{this.parseExpression(e)}while(this.current.index<t&&this.nextToken.type!==s)},this.next=()=>(this.current=this.nextToken,this.nextToken=this.tokens.next()),this.matchToken=e=>void 0===e||(Array.isArray(e)?-1!==e.indexOf(this.nextToken.value):"function"==typeof e?e(this.nextToken):("string"==typeof e||"number"==typeof e)&&e===this.nextToken.value),this.accept=(e,t,s=!0)=>!(!this.nextToken||this.nextToken.type!==e||!this.matchToken(t))&&(s&&this.next(),!0),this.expect=(e,t)=>{if(this.accept(e,t))return!0;{const{line:e,column:r}=this.tokens.getCoordinates();throw this.printLog(`> line:${e} column:${r-1} "${this.current.value}"\nThe next tag should be "${t}", But the reality is`,""+(this.nextToken.type===s?"empty content":`"${this.nextToken.value}"`),console.error),new Error("Unexpected Tag")}},this.temporarySaved=()=>{this.savedCurrent=this.current,this.savedNextToken=this.nextToken,this.tokens.temporarySaved()},this.restore=()=>{this.current=this.savedCurrent,this.nextToken=this.savedNextToken,this.tokens.restore()},this.parseExpression=e=>{const t=[];this.parseMultipleEvaluation(t),t.forEach(t=>e.push(t))},this.parseMultipleEvaluation=e=>{for(this.parseAssignmentExpression(e);this.accept(r,",");)this.parseConditionalExpression(e)},this.parseAssignmentExpression=e=>{for(this.parseConditionalExpression(e);this.accept("TOKEN_OP","=");){let s;"INSTR_VAR"===e[e.length-1].type&&(s=e.pop());const r=[];this.parseConditionalExpression(r),e.push(new t("INSTR_EXPRE",r)),s?e.push(s):e.push(new t("INSTR_OP2","="))}},this.parseConditionalExpression=e=>{for(this.parseOrExpression(e);this.accept("TOKEN_OP","?");){const s=[],r=[];this.parseConditionalExpression(s),this.expect("TOKEN_OP",":"),this.parseConditionalExpression(r),e.push(new t("INSTR_EXPRE",s)),e.push(new t("INSTR_EXPRE",r)),e.push(new t("INSTR_OP3","?"))}},this.parseOrExpression=e=>{for(this.parseAndExpression(e);this.accept("TOKEN_OP","||");){var s=[];this.parseAndExpression(s),e.push(new t("INSTR_EXPRE",s)),e.push(new t("INSTR_OP2","||"))}},this.parseAndExpression=e=>{for(this.parseBitwiseOrExpression(e);this.accept("TOKEN_OP","&&");){var s=[];this.parseBitwiseOrExpression(s),e.push(new t("INSTR_EXPRE",s)),e.push(new t("INSTR_OP2","&&"))}},this.parseBitwiseOrExpression=e=>{for(this.parseBitwiseAndExpression(e);this.accept("TOKEN_OP","^");)this.parseBitwiseAndExpression(e),e.push(new t("INSTR_OP2","^"))},this.parseBitwiseAndExpression=e=>{for(this.parseEqualExpression(e);this.accept("TOKEN_OP","&");)this.parseBitwiseAndExpression(e),e.push(new t("INSTR_OP2","&"))},this.parseEqualExpression=e=>{for(this.parseCompareExpression(e);this.accept("TOKEN_OP",["==","===","!=","!=="]);){var s=this.current;this.parseCompareExpression(e),e.push(new t("INSTR_OP2",s.value))}},this.parseCompareExpression=e=>{for(this.parseInOrAtExpression(e);this.accept("TOKEN_OP",["<","<=",">=",">"]);){var s=this.current;this.parseInOrAtExpression(e),e.push(new t("INSTR_OP2",s.value))}},this.parseInOrAtExpression=e=>{for(this.parseBitwiseMoveExpression(e);this.accept("TOKEN_OP",["in"]);){var s=this.current;this.parseBitwiseMoveExpression(e),e.push(new t("INSTR_OP2",s.value))}},this.parseBitwiseMoveExpression=e=>{for(this.parseAddOrSubExpression(e);this.accept("TOKEN_OP",[">>",">>>","<<"]);){var s=this.current;this.parseAddOrSubExpression(e),e.push(new t("INSTR_OP2",s.value))}},this.parseAddOrSubExpression=e=>{for(this.parseMulOrDivExpression(e);this.accept("TOKEN_OP",["+","-"]);){var s=this.current;this.parseMulOrDivExpression(e),e.push(new t("INSTR_OP2",s.value))}},this.parseMulOrDivExpression=e=>{for(this.parseUnaryExpression(e);this.accept("TOKEN_OP",["*","/","%"]);){var s=this.current;this.parseUnaryExpression(e),e.push(new t("INSTR_OP2",s.value))}},this.parseUnaryExpression=e=>{if(this.temporarySaved(),this.accept("TOKEN_OP",L))if(B.test(this.current.value)){const s=this.current;this.parseUnaryExpression(e),e.push(new t("INSTR_OP1",s.value))}else if(this.accept("TOKEN_PAREN","(",!1)){const s=this.current;this.accept("TOKEN_PAREN","("),this.parseConditionalExpression(e),this.expect("TOKEN_PAREN",")"),e.push(new t("INSTR_OP1",s.value))}else if(-1!==[r,i,s].indexOf(this.nextToken.type)||"TOKEN_PAREN"===this.nextToken.type&&")"===this.nextToken.value)this.restore(),this.parseField(e);else{const s=this.current;this.parseUnaryExpression(e),e.push(new t("INSTR_OP1",s.value))}else this.parseOuterFunctionCallExpression(e)},this.parseOuterFunctionCallExpression=e=>{this.parseMemberAccessExpression(e),this.current.type===n&&this.accept("TOKEN_PAREN","(",!1)&&this.parseArguments(e)},this.parseArguments=e=>{for(;this.accept("TOKEN_PAREN","(");)if(this.accept("TOKEN_PAREN",")"))e.push(new t("INSTR_FUNCALL",0));else{let s=0;for(;!this.accept("TOKEN_PAREN",")");)do{this.parseConditionalExpression(e),s++}while(this.accept(r));e.push(new t("INSTR_FUNCALL",s))}},this.parseMemberAccessExpression=e=>{this.parseField(e);const s=[],r=e[e.length-1];for(r&&"INSTR_NAME"===r.type&&s.push(r.value);this.accept("TOKEN_OP",".")||c(["TOKEN_SQUARE",n],this.current.type)&&this.accept("TOKEN_SQUARE","[");){if(!this.ceval.getOptions().allowMemberAccess)throw new Error('options "allowMemberAccess": You have disabled member access and cannot use syntax such as "a.b" "a[\'b\']"');"."===this.current.value?(this.expect(n),s.push(this.current.value)):"["===this.current.value&&(this.accept(n)||this.accept("TOKEN_NUMBER")||this.accept("TOKEN_STRING"))&&(s.push(this.current.value),this.expect("TOKEN_SQUARE","]"))}s.length>1&&(e.pop(),e.push(new t("INSTR_MEMBER",s)))},this.parseField=e=>{if(this.accept("TOKEN_OP",L))e.push(new t("INSTR_OP1",this.current.value));else if(this.accept(n))this.accept("TOKEN_OP","=",!1)?e.push(new t("INSTR_VARNAME",this.current.value)):e.push(new t("INSTR_NAME",this.current.value));else if(this.accept("TOKEN_NUMBER"))e.push(new t("INSTR_NUMBER",this.current.value));else if(this.accept("TOKEN_STRING"))e.push(new t("INSTR_PLAIN",this.current.value));else if(this.accept("TOKEN_PAREN","("))this.parseExpression(e),this.expect("TOKEN_PAREN",")");else if(this.accept("TOKEN_SQUARE","["))this.parseArrayLiteralDeclaration(e);else if(this.accept("TOKEN_CURLY","{",!1))this.parseObjectLiteralDeclaration(e);else if(this.accept("TOKEN_VAR",["const","var","let"])){const s=this.current;this.expect(n),e.push(new t("INSTR_VARNAME",this.current.value)),e.push(new t("INSTR_VAR",s.value))}else if(this.accept("TOKEN_FUNC",void 0,!1))this.parseFunctionDefinedDeclaration(e);else if(!this.accept(i))throw new Error("unexpected "+this.nextToken)},this.parseArrayLiteralDeclaration=e=>{const s=[];this.accept("TOKEN_SQUARE","]")||(this.parseExpression(s),this.expect("TOKEN_SQUARE","]")),e.push(new t("INSTR_ARRAY",s))},this.parseObjectLiteralDeclaration=e=>{for(;this.accept("TOKEN_CURLY","{");){const s={};if(this.accept("TOKEN_CURLY","}"))return void e.push(new t("INSTR_OBJECT",s));for(;this.accept(n)||this.accept("TOKEN_NUMBER")||this.accept("TOKEN_STRING");){const e=this.current.value;this.expect("TOKEN_OP",":"),s[e]=[],this.accept("TOKEN_CURLY","{",!1)?this.parseObjectLiteralDeclaration(s[e]):this.parseConditionalExpression(s[e]),this.accept(r,",")}this.expect("TOKEN_CURLY","}"),this.accept(i,";"),e.push(new t("INSTR_OBJECT",s))}},this.parseFunctionDefinedDeclaration=e=>{for(;this.accept("TOKEN_FUNC");)if(this.accept(n)){const s=this.current.value,n=[];if(this.accept("TOKEN_PAREN","(")){do{this.parseField(n)}while(this.accept(r));this.expect("TOKEN_PAREN",")")}this.parseFunctionBodyExpression(n),e.push(new t("INSTR_FUNCDEF",n)),e.push(new t("INSTR_FUNCDEF",s))}},this.parseFunctionBodyExpression=e=>{if(this.accept("TOKEN_CURLY","{")){const s=[];do{this.parseExpression(s)}while(this.accept(i,";")&&!this.accept("TOKEN_CURLY","}",!1));if(this.current.type!==i)throw new SyntaxError("Function parse error: Function body each line must end with semicolon ';'");this.expect("TOKEN_CURLY","}"),this.accept(i,";"),e.push(new t("INSTR_EXPRE",s))}},this.printLog=(e,t,s=console.log)=>{s(`${e} %c${t}`,"margin: 0 .5em;text-decoration-line: underline;text-decoration-color: red;text-decoration-style: wavy;line-height: 2em;color: red;")},this.next(),this.inspectParseEnd(a)}}return e.generatorParser=(t,s,r)=>new e(t,s,r),e})();const G={abstract:!1,arguments:!1,boolean:!1,break:!1,byte:!1,case:!1,catch:!1,char:!1,class:!1,const:!1,continue:!1,debugger:!1,default:!1,delete:!1,do:!1,double:!1,else:!1,enum:!1,eval:!1,export:!1,extends:!1,final:!1,finally:!1,float:!1,for:!1,function:!1,goto:!1,if:!1,implements:!1,import:!1,in:!0,instanceof:!1,int:!1,interface:!1,let:!1,long:!1,native:!1,new:!1,null:!1,package:!1,private:!1,protected:!1,public:!1,return:!0,short:!1,static:!1,super:!1,switch:!1,synchronized:!1,this:!1,throw:!1,throws:!1,transient:!1,try:!1,typeof:!1,var:!1,void:!1,volatile:!1,while:!1,with:!1,yield:!1},X={Array:!1,Date:!1,eval:!1,function:!1,hasOwnProperty:!1,Infinity:!1,isFinite:!1,isNaN:!1,isPrototypeOf:!1,length:!1,Math:!1,NaN:!0,name:!1,Number:!1,Object:!1,prototype:!1,String:!1,toString:!1,undefined:!1,valueOf:!1};class Q{constructor(e,t){this.ceval=e,this.expression=t,this.pos=0,this.current=null,this.savedPosition=0,this.savedCurrent=null,this.checkNextAccessGrammar=()=>{this.temporarySaved();const e=this.next();return this.restore(),e},this.getSomeCode=(e=1,t=0)=>{const s=t+this.pos,{length:r}=this.expression;return this.expression.substr(s,s+e>r?r-s:e)},this.getFirstWord=()=>{const e=this.expression.substr(this.pos).match(/\b\w*\b/);return e?e[0]:""},this.newToken=(e,t,s)=>new o(e,t,null!=s?s:this.pos),this.next=()=>this.expression.length?this.pos>=this.expression.length?this.newToken(s,"END"):this.isWhiteSpace()||this.isComment()?this.next():this.isNumber()||this.isString()||this.isBoolean()||this.isParenthesis()||this.isComma()||this.isOperator()||this.isSemicolon()||this.isConst()||this.isVariable()||this.isFunctionDefined()||this.isName()?this.current:void this.parseError("unknown character: "+this.expression.charAt(this.pos),SyntaxError):this.newToken(n,"undefined"),this.temporarySaved=()=>{this.savedPosition=this.pos,this.savedCurrent=this.current},this.restore=()=>{this.pos=this.savedPosition,this.current=this.savedCurrent},this.isWhiteSpace=()=>{const e=_.exec(this.getSomeCode());for(;e&&e[1];)return this.pos++,!0;return!1},this.isComment=()=>{const e=this.getSomeCode(2);let t;return"/*"===e?t=V(R,this.getSomeCode(1/0)):"//"===e&&(t=V(/^(\/\/.*\n?)/,this.getSomeCode(1/0))),!!t&&(this.pos+=t.length+("/*"===e?4:0),!0)},this.isBoolean=()=>{const e=S.exec(this.getSomeCode());for(;e&&e[1];)return this.pos++,!0;return!1},this.isVariable=()=>{const e=this.getFirstWord();if(c(["const","var","let"],e)){this.pos+=e.length,this.current=this.newToken("TOKEN_VAR",e);const t=this.checkNextAccessGrammar();if(t.type!==n)throw new Error(`${e} ${t.value} : This syntax Not as expected, should be "${n}", but is "${t}"`);if(c(this.ceval.consts,t.value))throw new SyntaxError(`SyntaxError:  Unexpected token '${t.value}', it has been stated in consts.`);return!0}return!1},this.isNumber=()=>{const e=this.getSomeCode();let t,s;const r=this.getSomeCode(this.expression.length-this.pos);if(!1===/\d|\./.test(e)||"."===e&&!1===/\.\d/.test(this.getSomeCode(2)))return!1;const[n]=r.match(/^(0(x|b)+[0-9a-zA-Z]{1,})|(^0?\d*(\.\d+)?)/);if(K.lastIndex=0,"0"===e&&n.length>1&&!/^0\.\d/.test(n)){if(c(["b","x"],this.getSomeCode(1,1))&&"."===this.getSomeCode(1,n.length))return this.parseError(`number '${n}' cannot is a floating point number, but actual is: '${n}${this.getSomeCode(3,n.length)}'`,SyntaxError),!1;if(C.test(n))t=V(C,n),s=void 0===t?void 0:2;else if(k.test(n))t=V(k,n),s=void 0===t?void 0:8;else if(M.test(n))t=V(M,n),s=void 0===t?void 0:16;else{if(!I.test(n))return this.parseError("number bitbase parser error",SyntaxError),!1;t=V(I,n),s=void 0===t?void 0:10}if(void 0!==t&&!this.ceval.getOptions().endableBitNumber)throw new Error('options "endableBitNumber": You have disabled bitbase number parsing, Not allowed '+t)}else if(j.test(r)){const[,,e,n]=j.exec(r);t=(Number(e)*Math.pow(10,Number(n))).toString(),s=10}else{if(!K.test(r))return!1;t=V(K,r),s=void 0===t?void 0:10}return this.current=10===s?this.newToken("TOKEN_NUMBER",parseFloat(t)):this.newToken("TOKEN_NUMBER",parseInt(t.replace("0b","").replace("0x",""),s)),this.pos+=t.length,!0},this.isString=()=>{const e=this.getSomeCode(),t=this.getSomeCode(1/0);let s,r;return('"'===e||"'"===e)&&(P.lastIndex=0,s=P.exec(t),r=u(s[1],s[2]),function(e){let t=0;for(;c(["'",'"'],e.charAt(t))&&e.charAt(t)===e.charAt(e.length-1-t);)t++;const s=e.substring(t,e.length-t);return-1===s.indexOf('"')&&-1===s.indexOf("'")}(r)||(A.lastIndex=0,s=A.exec(t),r=u(s[1],s[2])),void 0!==r)&&(this.current=this.newToken("TOKEN_STRING",r,this.pos),this.pos+=r.length+2*e.length,!0)},this.isFunctionDefined=()=>{const e=this.getFirstWord();if("function"===e){this.current=this.newToken("TOKEN_FUNC",void 0),this.pos+=e.length;return this.checkNextAccessGrammar().type===n||(this.parseError("function definition should have function name"),!1)}return!1},this.isName=()=>{const e=this.getSomeCode();let t;return("_"===e||"$"===e||/^[a-zA-Z]/.test(e))&&($.lastIndex=0,t=$.exec(this.getSomeCode(1/0))),null!=t&&"string"==typeof t[1]&&(t=t[1],!1===G[t]?(this.parseError("parser an reserved word: "+t),!1):!1===X[t]?(this.parseError("parser an window native attributes or methods: "+t),!1):(this.pos+=t.length,this.current=this.newToken(n,t),!0))},this.isConst=()=>{D.lastIndex=0;const e=D.exec(this.getSomeCode(1/0));if(e&&e[1]){this.current=this.newToken(n,e[1]),this.pos+=e[1].length;const t=this.checkNextAccessGrammar();return"TOKEN_OP"===t.type&&"="===t.value&&this.parseError(`parser error: consts of ${this.current.value} can not assignment;`,SyntaxError),!0}return!1},this.isSemicolon=()=>";"===this.getSomeCode()&&(this.current=this.newToken(i,";"),this.pos++,!0),this.isComma=()=>","===this.getSomeCode()&&(this.current=this.newToken(r,","),this.pos++,!0),this.isParenthesis=()=>{var e=this.getSomeCode();if(c(["(",")"],e))this.current=this.newToken("TOKEN_PAREN",e);else if(c(["[","]"],e))this.current=this.newToken("TOKEN_SQUARE",e);else{if(!c(["{","}"],e))return!1;this.current=this.newToken("TOKEN_CURLY",e)}return this.pos++,!0},this.isOperator=()=>{const e=this.getSomeCode(1/0);let t;if(U.test(e)?t=V(U,e):F.test(e)&&(t=V(F,e)),!t)return!1;if(!1===this.ceval.getOptions().endableOperators)throw new Error(`options "endableOperators": You disabled the operator, Therefore, "${t}" it can not be used`);return t=t.replace(/\s/g,""),this.pos+=t.length,this.current=this.newToken("TOKEN_OP",t),!0},this.getCoordinates=()=>{let e=0,t=0,s=-1;do{e++,t=this.pos-s,s+=1,s+=this.expression.substr(s).indexOf("\n")}while(s>=0&&s<this.pos&&e<this.pos);return{line:e,column:t}},this.parseError=(e,t=Error)=>{var s=this.getCoordinates();throw new t("parse error ["+s.line+":"+s.column+"] => "+e)}}}function H(e,s=Object.create(null),r,n=!1,i=Object.create(null)){window.name&&(console.group("calclation Dev"),console.log("tokens: ",e),console.log("values",s),console.log("scope",i),console.groupEnd());const o=r.getOptions(),{unaryOps:a,binaryOps:h,ternaryOps:c}=r,u=[],{length:d}=e;let N,T,w,x;for(let g=0;g<d;g++){const y=e[g],{type:v,value:b}=y||{};if(v)switch(v){case"INSTR_NUMBER":case"INSTR_PLAIN":case"INSTR_VARNAME":u.push(b);break;case"INSTR_NAME":if(l(i,b))u.push(i[b]);else if(l(s,b))u.push(s[b]);else if(l(r.consts,b))u.push(r.consts[b]);else{if(!l(r.functions,b))throw new Error(b+" is not defined in values or consts");u.push(r.functions[b])}break;case"INSTR_OP1":if(0===u.length)break;[N]=u.splice(-1,1),x=W(b,[s,a],o.allowOperatorsCovered),u.push(x(N)),"return"===b&&(g=d);break;case"INSTR_OP2":if(u.length<2)break;[N,T]=u.splice(-2,2),x=W(b,[s,h],o.allowOperatorsCovered),"&&"===b?u.push(x(N,H([T],s,r,n,i),!1)):"="===b?N instanceof O?(N.setValue(T),N.destory()):(E(l(i,N),l(s,N),N+" is not define in values or current scope, if you are declaring a new variable, please add var, const or let operator"),x(N,T,l(i,N)?i:s)):u.push(x(N,H([T],s,r,n,i),o));break;case"INSTR_OP3":if(u.length<3)break;[N,T,w]=u.splice(-3,3),x=W(b,[s,c],o.allowOperatorsCovered),u.push(x(N,T,w));break;case"INSTR_EXPRE":u.push(H(y.value,s,r,n,i));break;case"INSTR_MEMBER":{const t=e[g+2],r=f(b,i,s);t&&"INSTR_OP2"===t.type&&"="===t.value?u.push(r):(u.push(r.getValue()),r.destory());break}case"INSTR_ARRAY":u.push(H(b,s,r,!0,i));break;case"INSTR_OBJECT":{const e=Object.create(null);Object.keys(b).forEach(t=>{e[t]=H(b[t],s,r,n,i)}),u.push(e);break}case"INSTR_VAR":switch([N,T]=u.splice(-2,2),b){case"let":case"const":l(i,N)&&console.warn(N+" already statement in consts or scope"),i[N]=T;break;case"var":s[N]=T;break;default:console.warn("Unexpected statement identifier")}break;case"INSTR_FUNCALL":{const e=u.splice(-b,b);if(x=u.pop(),"function"==typeof x){u.push(x.apply(null,e));continue}x.value instanceof z&&(x.value.updateScope(e),u.push(x.value.invokeBody()));break}case"INSTR_FUNCDEF":{if("string"!=typeof b){u.push(b);continue}if(0===u.length)return;const e=p(Object.create(null),i);e[b]=new t("INSTR_EXECUTBODY",new z(u.pop(),s,e,r)),Object.assign(i,e);break}default:{const e=Symbol("_init");let t=e;try{t=y.value}catch(e){}t!==e&&u.push(t)}}else u.push(y)}return n?u:u[0]}function W(e,[t,s],r=!1){let n;return n=r&&l(t,e)?t[e]:s[e],n}class z{constructor(e,t,s,r){this.func=e,this.values=t,this._scope=s,this.ceval=r,this.updateScope=e=>{this.args.forEach((t,s)=>{l(this._scope,t)&&(this._scope[t]=e[s])})},this.invokeBody=()=>H(this.func,this.values,this.ceval,!1,this._scope);const n=this.func.splice(0,e.length-1);this.args=H(n,d(n,e=>e),r,!0),this._scope=p(d(n),s)}}const[q,J]=function(e=0){const t=new Date(Date.now()+e);return[`${t.getFullYear()}-${t.getMonth()+1}-${t.getDate()}`,`${t.getHours()}:${t.getMinutes()}:${t.getSeconds()}`.replace(/\d+/g,e=>parseInt(e,10)<10?"0"+e:e)]}();var Z={now:Date.now(),date:q,time:J};class ee{constructor(){this.endableOperators=!0,this.endableBitNumber=!0,this.allowMemberAccess=!0,this.allowHandleNumberPrecision=!0,this.allowOperatorsCovered=!1,this.defaultReturnValues=""}}return class{constructor(t={}){this.options=t,this.operatorMap=v,this.currentValues=e(Z),this.getSupportOperationMap=e=>Object.prototype.hasOwnProperty.call(v,e)?v[e]:null,this.parseString=(e,t={})=>{const s=[];let r;if("development"!==process.env.NODE_ENV)Y.generatorParser(this,new Q(this,e),s),r=this.injectValueToCalc(s,t);else try{Y.generatorParser(this,new Q(this,e),s),r=this.injectValueToCalc(s,t)}catch(e){console.error(e)}return r},this.getCurrentValues=()=>e(this.currentValues),this.injectValueToCalc=(e,t={})=>{this.updatePresetValues(t);const s=H(e,this.currentValues,this);return void 0===s?this.options.defaultReturnValues:s},this.updatePresetValues=e=>{Object.assign(this.currentValues,e)},this.updateOptions=e=>{Object.assign(this.options,e)},this.getOptions=()=>e(this.options),Object.assign(this,g),p(this.options,new ee)}}}));
//# sourceMappingURL=index.js.map
