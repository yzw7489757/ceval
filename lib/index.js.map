{"version":3,"file":"index.js","sources":["../src/instruction.ts","../src/token.ts","../src/utils/index.ts","../src/utils/functions.ts","../src/systemMap.ts","../src/utils/regExp.ts","../src/parser.ts","../src/utils/reservedWord.ts","../src/token-stream.ts","../src/calculation.ts","../src/utils/presetVariable.ts","../src/interface.ts","../src/index.ts"],"sourcesContent":["/** @desc 一元运算符 */\nexport const INSTR_OPERA1 = 'INSTR_OP1';\n/** @desc 二元运算符 */\nexport const INSTR_OPERA2 = 'INSTR_OP2';\n/** @desc 三元运算符 */\nexport const INSTR_OPERA3 = 'INSTR_OP3';\n\n/** @desc 数字 */\nexport const INSTR_NUMBER = 'INSTR_NUMBER';\n/** @desc 数组字面量 */\nexport const INSTR_ARRAY = 'INSTR_ARRAY';\n/** @desc 对象字面量 */\nexport const INSTR_OBJECT = 'INSTR_OBJECT';\n/** @desc 简单类型，表示不用处理 */\nexport const INSTR_PLAIN = 'INSTR_PLAIN';\n\n/** @desc 对象成员访问 */\nexport const INSTR_MEMBER = 'INSTR_MEMBER';\n\n/** @desc 表达式, 内置表达式 */\nexport const INSTR_EXPRE = 'INSTR_EXPRE';\n\n/** @desc 变量类型 const let var */\nexport const INSTR_VAR = 'INSTR_VAR';\n/** @desc 变量名称, 区别是内声明 TODO: var obj = {} */\nexport const INSTR_VARNAME = 'INSTR_VARNAME';\n/** @desc 变量名称, 取值, 没有经过声明的名称，例如 undefined, null, 以及数据池中的数据 */\nexport const INSTR_NAME = 'INSTR_NAME';\n\n/** @desc 函数调用 */\nexport const INSTR_FUNCALL = 'INSTR_FUNCALL'; // TODO: 函数声明\n/** @desc 函数定义指令 */\nexport const INSTR_FUNCDEF = 'INSTR_FUNCDEF';\n/** @desc 函数执行体 */\nexport const INSTR_EXECUTBODY = 'INSTR_EXECUTBODY';\n\n\n/**\n * @desc 指令实例\n */\nexport default class Instruction<T extends any> {\n\n  value: T;\n\n  constructor(public type: string, value?: any) {\n    this.value = (value !== undefined && value !== null) ? value : 0;\n  }\n}\n\n","/** @desc 结束标记 */\nexport const TOKEN_END = 'TOKEN_END';\n/** @desc 操作符类型 */\nexport const TOKEN_OPERATOR = 'TOKEN_OP';\n/** @desc 数字类型 */\nexport const TOKEN_NUMBER = 'TOKEN_NUMBER';\n/** @desc 字符串类型 */\nexport const TOKEN_STRING = 'TOKEN_STRING';\n/** @desc 圆括号，调用 */\nexport const TOKEN_PAREN = 'TOKEN_PAREN';\n/** @desc 方括号，成员访问 [] */\nexport const TOKEN_SQUARE = 'TOKEN_SQUARE';\n/** @desc 花括号，字面量声明 */\nexport const TOKEN_CURLY = 'TOKEN_CURLY';\n/** @desc 逗号 , */\nexport const TOKEN_COMMA = 'TOKEN_COMMA';\n/** @desc 变量 , */\nexport const TOKEN_VAR = 'TOKEN_VAR';\n/** @desc 变量名称 */\nexport const TOKEN_NAME = 'TOKEN_NAME';\n/** @desc 函数定义 */\nexport const TOKEN_FUNC = 'TOKEN_FUNC';\n/** @desc 结束标记; */\nexport const TOKEN_SEMICOLON = 'TOKEN_SEMICOLON';\n\n/**\n * tokenStream 解析阶段指令\n * @export \n * @class Token\n */\nexport default class Token {\n  constructor(public type: string, public value: any, public index: number) {\n    this.toString = this.toString.bind(this);\n  }\n\n  toString = () => {\n    return this.type + ': ' + this.value;\n  };\n}\n\n","import Instruction from '../instruction';\n\nconst { toString } = Object.prototype;\n\n\nexport function isObject(obj): obj is object {\n  return toString.call(obj) === '[object Object]'\n}\n\n/**\n * @export\n * @template T\n * @param {array|object|string} source \n * @param {string} value\n * @returns {boolean}\n */\nexport function contains(source: any[] | Record<any, any> | string, value: string): boolean {\n  if (isObject(source)) {\n    return Object.prototype.hasOwnProperty.call(source, value)\n  } else if (Array.isArray(source)) {\n    return source.some(v => v === value)\n  }\n  return source.indexOf(value) > -1\n}\n\n/**\n * 获取日期时间\n * @export getTime\n * @param {number} [offset=0] 偏移量\n * @returns {string[]} [date, time]\n */\nexport function getTime(offset = 0): string[] {\n  const o = new Date(Date.now() + offset);\n  const date = `${o.getFullYear()}-${o.getMonth() + 1}-${o.getDate()}`\n  const clock = `${o.getHours()}:${o.getMinutes()}:${o.getSeconds()}`.replace(/\\d+/g, (t) => {\n    return parseInt(t, 10) < 10 ? `0${t}` : t\n  })\n\n  return [date, clock]\n}\n\n\n/**\n * 递归foreach\n * @export mapVal\n * @template T\n * @param {T} data\n * @param {Record<string, Record<string, any>>} object\n * @param {(data: T, key:string, val: any) => void} cb\n * @returns\n */\nexport function mapVal<T extends object>(data: T, object: object, cb: (data: T, key: string, val: any) => void) {\n  Object.keys(object).map(key => {\n    return isObject(object[key]) ? mapVal(data, object[key], cb) : cb(data, key, object[key])\n  })\n  return data\n}\n\n/**\n * 前者为主，仅合并不存在属性\n * @template T object\n * @param {T} target\n * @param {T} source\n */\nexport function merge<T>(target: T, source: T) {\n  Object.keys(source).forEach(key => {\n    const val = source[key]\n    if (Object.prototype.hasOwnProperty.call(target, key)) return\n    if (Array.isArray(val)) {\n      merge(target[key] = [], val)\n    } else if (isObject(val)) {\n      merge(target[key] = {}, val)\n    } else {\n      target[key] = val\n    }\n  })\n  return target\n}\n\n/**\n * 替换\\'\\' \\\"\\\" 在 处理 in operator 需要到\n * @param {string} str string Field\n * @returns {string} 没有对称引号的字符串\n */\nexport function eliminateQuote(str: string): string {\n  const quoteReg = /^\\\"(.*)\\\"$|^\\'(.*)\\'$/;\n  if (!quoteReg.test(str)) return str\n  const result = quoteReg.exec(str)\n  const s = result[1] !== undefined ? result[1] : result[2]\n  return eliminateQuote(s)\n}\n/**\n * 回文字符串 \\'\\'a\\'\\' ✅  \\'\\'a\\'❌\n * @param {string} str\n * @returns\n */\nexport function isPalindrome(str: string) {\n  let i = 0\n  while (contains(['\\'', '\\\"'], str.charAt(i)) && str.charAt(i) === str.charAt(str.length - 1 - i)) {\n    i++\n  }\n  const surplusStr = str.substring(i, str.length - i)\n  return surplusStr.indexOf('\\\"') === -1 && surplusStr.indexOf('\\'') === -1\n}\n\n/**\n * 返回首个有效数据， 非undefined null false true\n * @param {*} args\n */\nexport function filterUndefine(...args) {\n  let one\n  args.some(item => {\n    if (contains([undefined, null, true, false], item)) return false\n    one = item\n    return true;\n  })\n  return one\n}\n\n\nexport function hasAttribute(obj: object, name: string) {\n  return Object.prototype.hasOwnProperty.call(obj, name)\n}\n\nexport function unique(source:any[]) {\n  const arr = [];\n  source.forEach(element => {\n    if (arr.indexOf(element) === -1) arr.push(arr);\n  });\n  return arr\n}\n\n/**\n * Array to Object e.g. ['a', 'b'] => { a: undefined, b: undefined }\n * @param {string[]} arr \n */\nexport function mapToObject(arr: string[] | Instruction<any>[], defaultValue: undefined | ((key: string) => any) = undefined) {\n  if (typeof arr[0] === 'string' && arr.length !== unique(arr).length) {\n    // 参数重复\n    throw new Error(`Duplicate parameter: ${arr.join(',')}`)\n  }\n  const obj = Object.create(null)\n  arr.forEach((item) => {\n    let key\n    if (item instanceof Instruction) {\n      key = item.value\n    } else {\n      key = item\n    }\n    obj[key] = (typeof defaultValue === 'function' ? defaultValue(key) : defaultValue)\n  })\n  return obj\n}\n\nexport function someCondition(...args) {\n  const errMsg = args.pop();\n\n  if (!args.find(d => !!d)) {\n    throw new Error(errMsg)\n  }\n}\n/**\n * \n * @param keyQueue [\"obj\", \"arr\"] key path\n * @param scope 当前作用域\n * @param values 顶层作用域\n */\nexport function getReference(keyQueue: string[], scope: Record<string, any>, values: Record<string, any>): Reference {\n  if (keyQueue.length < 2) return hasAttribute(scope, keyQueue[0]) ? scope[keyQueue[0]] : values[keyQueue[0]];\n  let path = keyQueue.shift();\n  const lastKey = keyQueue.pop();\n  let target = hasAttribute(scope, path) ? scope : values;\n  while (path) {\n    if (hasAttribute(target, path)) {\n      target = target[path];\n    } else if (!target) {\n      throw new TypeError(`Uncaught TypeError: Cannot read property '${path}' of ${target}`)\n    } else {\n      target = undefined\n    }\n    path = keyQueue.shift()\n  }\n  return new Reference(target, lastKey)\n}\n\nexport class Reference {\n  destoryed: boolean;\n\n  constructor(public target: any, public path: string) {\n    this.destoryed = false\n  }\n\n  setValue(value) {\n    if(this.destoryed) return value\n    return (this.target[this.path] = value)\n  }\n\n  getValue() {\n    if(this.destoryed) return undefined\n    return this.target[this.path]\n  }\n\n  destory() {\n    // 使用一次就释放掉内存\n    this.destoryed = true\n    this.target = null;\n  }\n}","import { contains, isObject, eliminateQuote } from './index';\nimport { CevalOptions } from '../interface';\n\nfunction getDigitLength(num: number){\n  return (num.toString().split('.')[1] || '').length;\n}\n\nfunction checkBounds(number: number) {\n  return number > Number.MAX_SAFE_INTEGER || number < Number.MIN_SAFE_INTEGER\n}\n\nfunction getBaseNum(a: number, b: number): number {\n  const baseNum = Math.pow(10, Math.max(getDigitLength(a), getDigitLength(b)));\n  if(checkBounds(a * baseNum) || checkBounds(b * baseNum)) { // 超出边界的情况不予处理\n    return 0\n  }\n  return baseNum\n}\n\nconst unwantedHandlePercision = (a, b) => {\n  // 整数不需要处理 || 非Number也不需要\n  return (Number.isInteger(a) && Number.isInteger(b)) || (typeof a !== 'number' || typeof b !== 'number')\n}\n\nexport function add(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a + b\n  const baseNum = getBaseNum(a,b);\n  return baseNum === 0 ? a + b : (Math.round(a * baseNum) + Math.round(b * baseNum)) / baseNum \n}\n\nexport function sub(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a - b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a - b : (Math.round(a * baseNum) - Math.round(b * baseNum)) / baseNum;\n}\n\nexport function mul(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a * b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a * b : (Math.round(a * baseNum) * Math.round(b * baseNum)) / Math.pow(baseNum, 2);\n}\n\nexport function divide(a: number, b: number, options: CevalOptions): number {\n  if( options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a / b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a / b : (Math.round(a * baseNum) / Math.round(b * baseNum));\n}\n\nexport function mod(a, b) {\n  return a % b;\n}\n\nexport function equal(a, b) {\n  // eslint-disable-next-line\n  return a == b;\n}\n\nexport function strictEqual(a, b) {\n  return a === b;\n}\n\nexport function notEqual(a, b) {\n  // eslint-disable-next-line\n  return a != b;\n}\n\nexport function strictNotEqual(a, b) {\n  return a !== b;\n}\n\nexport function greaterThan(a, b) {\n  return a > b;\n}\n\nexport function lessThan(a, b) {\n  return a < b;\n}\n\nexport function greaterThanEqual(a, b) {\n  return a >= b;\n}\n\nexport function _typeof(a){\n  return Object.prototype.toString.call(a).match(/^\\[object\\s*(\\w+?)\\]$/)[1].toLowerCase()\n}\n\nexport function lessThanEqual(a, b) {\n  return a <= b;\n}\n\nexport function inTheTarget(a, b) {\n  if(typeof b !== 'object' || String(a) !== `${a}` ) throw new Error('first argument must be original type, second must be Array or Object')\n  return isObject(b) ? Object.prototype.hasOwnProperty.call(b, eliminateQuote(a)) : contains(b, a)\n}\n\nexport function bitWiseOr(a, b) {\n  return a ^ b\n}\n\nexport function setVar(name: string | number, value: any, variables: object | Array<any> ) {\n  if (variables) variables[name] = value;\n  return value;\n}\n\nexport function arrayIndex(array, index) {\n  return array[index | 0];\n}\n\nexport function condition(cond, yep, nope) {\n  return cond ? yep : nope;\n}\n\nexport function withOr(n1, n2) {\n  return n1 ? n1 : n2\n}\n\nexport function withAlso(n1, n2) {\n  return n1 ? n2 : n1\n}\n\nexport function max(...args: number[]) {\n  if (args.length === 1) {\n    return Math.max.apply(Math, args);\n  } else {\n    return Math.max.apply(Math, args);\n  }\n}\n\nexport function min(...args: number[]) {\n  if (args.length === 1) {\n    return Math.min.apply(Math, args);\n  } else {\n    return Math.min.apply(Math, args);\n  }\n}\n\nexport function arrayMap(f: (val: any, index?: number) => any, a: any[]) {\n  if (typeof f !== 'function') {\n    throw new Error('First argument is not a function');\n  }\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument is not an array');\n  }\n  return a.map(function (x, i) {\n    return f(x, i);\n  });\n}\n\nexport function random(a) {\n  return Math.random() * (a || 1);\n}\n\nfunction decimalAdd(num1, num2) {\n  const num1Digits = (num1.toString().split('.')[1] || '').length;\n  const num2Digits = (num2.toString().split('.')[1] || '').length;\n  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}","import { mapVal } from './utils/index';\nimport {\n  // 功能性\n  random, min, max, arrayMap as map, _typeof,\n  // 二元\n  add, sub, mul, divide, mod, withOr, withAlso, equal, notEqual, greaterThan, lessThan, greaterThanEqual, lessThanEqual, inTheTarget, setVar, arrayIndex, bitWiseOr, strictNotEqual,\n  // 三元\n  condition,\n  strictEqual\n} from './utils/functions';\n\nconst system = {\n  functions: {\n    random,\n    min,\n    max,\n    map,\n    pow: Math.pow,\n  },\n  consts: {\n    E: Math.E,\n    PI: Math.PI,\n    'true': true,\n    'false': false,\n    \"undefined\": undefined,\n    \"null\": null,\n    \"NaN\": Number.NaN,\n    \"Infinity\": Infinity\n  },\n  binaryOps: {\n    '+': add,\n    '-': sub,\n    '*': mul,\n    '/': divide,\n    '%': mod,\n    '^': bitWiseOr,\n    '||': withOr,\n    '&&': withAlso,\n    '==': equal,\n    '!=': notEqual,\n    '!==': strictNotEqual,\n    '>': greaterThan,\n    '<': lessThan,\n    '>=': greaterThanEqual,\n    '<=': lessThanEqual,\n    '=': setVar,\n    '[': arrayIndex,\n    '===': strictEqual,\n    'in': inTheTarget,\n    // 'instanceOf'\n  },\n  ternaryOps: {\n    '?': condition\n  },\n  unaryOps: {\n    '+': (v): number => +v,\n    '-': (v): number => -v,\n    '!': (v): boolean => !v,\n    '~': (v): number => ~v,\n    '++': (v): number => v += 1,\n    '--': (v): number => v -= 1,\n    'typeof': (v): string => _typeof(v),\n    'return': v => v,\n    sin: Math.sin,\n    cos: Math.cos,\n    tan: Math.tan,\n  },\n  syntaxOperator: {\n    ':': null,\n    '.': null,\n  }\n}\n\nexport default system;\n\n/** @desc 功能函数 */\nexport type TypeFunction = typeof system.functions;\n/** @desc 常量设置 */\nexport type TypeConst = typeof system.consts;\n/** @desc 一元运算符 */\nexport type TypeUnary = typeof system.unaryOps;\n/** @desc 二元运算符 */\nexport type TypeBinary = typeof system.binaryOps;\n/** @desc 三元运算符 */\nexport type TypeTernary = typeof system.ternaryOps;\n/** @desc 词法操作符 */\nexport type TypeSyntax = typeof system.syntaxOperator;\n\n// 有些运算符不能被修改。\n\nconst excludeOperator = ['=', '['];\n\n/** @desc 运算符映射表 */\nexport const operatorMap = mapVal(Object.create(null), {\n  functions: system.functions,\n  consts: system.consts,\n  unaryOps: system.unaryOps,\n  ternaryOps: system.ternaryOps,\n}, (maps, key, val) => {\n  if(!excludeOperator.includes(key)) {\n    maps[key] = val\n  }\n})","/** \n * @desc   : desc \n * @author : ziwen\n * @date   : 2020-6-2 10:55:30\n */\nimport system from '../systemMap';\nimport { contains } from './index';\n\nconst BLACK_LIST_OPERATORS = []\nconst supportOperator = Array.from(new Set(\n  [].concat(\n    Object.keys(system.unaryOps).filter(item => !/\\b\\w+\\b/.test(item)),\n    Object.keys(system.binaryOps),\n    Object.keys(system.ternaryOps),\n    Object.keys(system.syntaxOperator)\n  )\n    .filter(op => !contains(BLACK_LIST_OPERATORS, op))\n    .sort((a, b) => b.length - a.length)\n))\n\nexport const whitespaceReg = /(\\t|\\n|\\r|\\s+)/;\nexport const booleanReg = /^(false|true)/;\nexport const commentReg = /^\\/\\*(.*?)\\*\\//;\nexport const stringReg = /^\\'(.*?)\\'|^\\\"(.*?)\\\"/;\nexport const stringGreedyReg = /^\\'(.*)\\'|^\\\"(.*)\\\"/;\n// export const regExpReg = /^ExecReg\\((.*)\\)/;\n\nexport const number2bitReg = /^(0b[0|1]{1,})$/;\nexport const number8bitReg = /^(0[0-7]{1,})$/;\nexport const number010bitReg = /^(0\\d*[8-9]{1,}\\d*(\\.\\d+)?)$/; // 0开头的十进制 019 038 078\nexport const number10bitReg = /(^([1-9]\\d*(\\.\\d+)|(\\d*(\\.\\d+)?)))/; // 1-9 或者.开头的十进制\nexport const number16bitReg = /^(0x[0-9a-fA-F]{1,})$/;\nexport const numberEbitReg =  /^((\\d*\\.?\\d*)[e|E]((\\-|\\+)?\\d+))/; // 科学计数法\n\nexport const variableReg = /^((_|$)?[0-9a-zA-Z|$|_]{1,})/;\nexport const operatorReg = new RegExp(`^(${supportOperator.map(r => `(\\\\${/\\b\\w+\\b/.test(r) ? `${r}\\\\s+` : r.split('').join('\\\\')})`).join('|')})`);\nexport const unaryMapReg = new RegExp(`^(${Object.keys(system.unaryOps).filter(item => /\\b\\w+\\b/.test(item)).join('|')})`);\nexport const unarySymbolMapReg = new RegExp(`^(${Object.keys(system.unaryOps).filter(item => !(/\\b\\w+\\b/.test(item))).map(r => `\\\\s*\\\\${r}\\\\s*`).join('|')})`);\nexport const constsMapReg = new RegExp(`^(${Object.keys(system.consts).map(k=>`${k}`).join('|')})`)\n\nexport const execFactoryReg = (reg: RegExp, expr: string, cb: <T>(v: T) => T = (v => v)): string | undefined => {\n  reg.lastIndex = 0;\n  const result = reg.exec(expr);\n  if (result === null || result[0] === '') {\n    return cb(undefined)\n  } else {\n    return cb(result[1])\n  }\n}\n\nexport const isUnaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.unaryOps, value)\nexport const isBinaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.binaryOps, value)\nexport const isTernaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.ternaryOps, value)","import Ceval from './index';\nimport { TypeTokenStream, TypeToken, TypeInstruction } from './interface';\nimport Instruction, { INSTR_EXPRE, INSTR_FUNCDEF, INSTR_PLAIN, INSTR_VARNAME, INSTR_NAME, INSTR_FUNCALL, INSTR_OBJECT, INSTR_OPERA1, INSTR_MEMBER, INSTR_OPERA2, INSTR_OPERA3, INSTR_ARRAY, INSTR_NUMBER, INSTR_VAR } from './instruction';\nimport { TOKEN_OPERATOR, TOKEN_NAME, TOKEN_SQUARE, TOKEN_PAREN, TOKEN_NUMBER, TOKEN_STRING, TOKEN_COMMA, TOKEN_SEMICOLON, TOKEN_END, TOKEN_CURLY, TOKEN_VAR, TOKEN_FUNC } from './token';\nimport { unarySymbolMapReg, isUnaryOpeator } from './utils/regExp';\nimport { contains } from './utils/index';\n\n/**\n * 解析器\n * @export\n * @class Parser\n */\nexport default class Parser {\n  /**\n   * @desc 当前TOKEN指针\n   */\n  current: TypeToken | null = null;\n\n  /**\n   * @desc 暂存指针\n   */\n  savedCurrent: TypeToken | null = null;\n\n  /**\n   * @desc 下个TOKEN指针对象\n   */\n  nextToken: TypeToken | null = null;\n\n  /**\n   * @desc 暂存next TOKEN\n   */\n  savedNextToken: TypeToken | null = null;\n\n  constructor(public ceval: Ceval, public tokens: TypeTokenStream, exprInstr: TypeInstruction[]) {\n    this.next();\n    \n    this.inspectParseEnd(exprInstr)\n  }\n\n  /**\n   * 检查是否解析完毕\n   */\n  private inspectParseEnd = (exprInstr: TypeInstruction[]) => {\n    const len = this.tokens.expression.length\n    do {\n      this.parseExpression(exprInstr)\n    } while (this.current.index < len && this.nextToken.type !== TOKEN_END) \n  }\n\n  /**\n   * 生成实例解析表达式，简化调用方式\n   */\n  static generatorParser = (parser: Ceval, tokens: TypeTokenStream, exprInstr: TypeInstruction[]): Parser => {\n    return new Parser(parser, tokens, exprInstr)\n  }\n\n  /**\n   * Token指针向下位移\n   */\n  next = (): TypeToken => {\n    this.current = this.nextToken;\n    return (this.nextToken = this.tokens.next())\n  }\n\n  /**\n   * 条件是否命中Token真值\n   */\n  matchToken = (value: undefined | ((value: TypeToken) => boolean) | string | number): boolean => {\n    if (value === undefined) {\n      return true\n    } else if (Array.isArray(value)) {\n      return value.indexOf(this.nextToken.value) !== -1\n    } else if (typeof value === 'function') {\n      return value(this.nextToken)\n    } else if (typeof value === 'string' || typeof value === 'number') {\n      return value === this.nextToken.value\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * 预判是否符合预期，符合&&解析下个token\n   * @param {type} 约定的类型\n   * @param {value} 明确规定的字面值，比如 ] , =\n   * @param {next} 允许next？\n   */\n  accept = (type: string, value?, next = true): boolean => {\n    if (this.nextToken && (this.nextToken.type === type) && this.matchToken(value)) {\n      if (next) this.next()\n      return true\n    }\n    return false\n  }\n\n  /**\n   * accpet + 断言\n   * @param {type} 约定的类型\n   * @param {value} 明确规定的字面值，比如 ] , =\n   */\n  expect = (type: string, value?): never | boolean => {\n    if (!this.accept(type, value)) {\n      const { line, column } = this.tokens.getCoordinates()\n      this.printLog(`> line:${line} column:${column - 1} \"${this.current.value}\"\\nThe next tag should be \"${value}\", But the reality is`, `${this.nextToken.type === TOKEN_END ? 'empty content' : `\"${this.nextToken.value}\"`}`\n        , console.error\n      )\n      throw new Error('Unexpected Tag');\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * 暂存指针，在某些情况下单一的nextToken已经不满足预判情况，例如 typeof(add) || add(1, 2) || 1 + add;\n   */\n  temporarySaved = (): void => {\n    this.savedCurrent = this.current;\n    this.savedNextToken = this.nextToken;\n\n    this.tokens.temporarySaved()\n  }\n\n  /**\n   * 恢复指针\n   */\n  restore = (): void => {\n    this.current = this.savedCurrent;\n    this.nextToken = this.savedNextToken;\n    this.tokens.restore()\n    return void 0;\n  }\n\n  /**\n   * 解析表达式整个句柄\n   * @see 如果只是求参或解析字面量，请从Conditional开始，因为MultipleEvaluation可能会误会语义，e.g.{a:1,b:2}中的“1,b:2”\n   */\n  parseExpression = (instr: TypeInstruction[]): void => {\n    const exprInstr: TypeInstruction[] = []\n    \n    this.parseMultipleEvaluation(exprInstr)\n    exprInstr.forEach(exp => (instr.push(exp)))\n  }\n\n  /**\n   * 解析连续求值 例如 数组字面量 [1, 2, [3, 4, 5]]  (1, 2, 3)\n   */\n  parseMultipleEvaluation = (exprInstr: TypeInstruction[]): void => {\n    this.parseAssignmentExpression(exprInstr)\n    while (this.accept(TOKEN_COMMA, ',')) {\n      this.parseConditionalExpression(exprInstr)\n    }\n  }\n\n  /**\n   * 解析变量赋值表达式 TOKEN_OPERATOR name = 1\n   */\n  parseAssignmentExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseConditionalExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '=')) {\n      let ident: TypeInstruction\n      if(exprInstr[exprInstr.length - 1].type === INSTR_VAR){\n        ident = exprInstr.pop()\n      };\n      const instr: TypeInstruction[] = []\n      this.parseConditionalExpression(instr)\n      exprInstr.push(new Instruction(INSTR_EXPRE, instr));\n      if(ident) {\n        exprInstr.push(ident)\n      } else {\n        exprInstr.push(new Instruction(INSTR_OPERA2, '='))\n      }\n    }\n  }\n\n  /**\n   * 解析三目运算符\n   */\n  parseConditionalExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseOrExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '?')) {\n      const trueBranch = [];\n      const falseBranch = [];\n      this.parseConditionalExpression(trueBranch);\n      this.expect(TOKEN_OPERATOR, ':');\n      this.parseConditionalExpression(falseBranch);\n      exprInstr.push(new Instruction(INSTR_EXPRE, trueBranch));\n      exprInstr.push(new Instruction(INSTR_EXPRE, falseBranch));\n      exprInstr.push(new Instruction(INSTR_OPERA3, '?'));\n    }\n  }\n\n  /**\n   * 解析 ||\n   */\n  parseOrExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseAndExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '||')) {\n      var branch = []\n      this.parseAndExpression(branch)\n      exprInstr.push(new Instruction(INSTR_EXPRE, branch))\n      exprInstr.push(new Instruction(INSTR_OPERA2, '||'))\n    }\n  }\n\n  /**\n   * 解析 &&\n   */\n  parseAndExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseOrExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '&&')) {\n      var branch = []\n      this.parseBitwiseOrExpression(branch)\n      exprInstr.push(new Instruction(INSTR_EXPRE, branch))\n      exprInstr.push(new Instruction(INSTR_OPERA2, '&&'))\n    }\n  }\n\n  /**\n   * 解析 ^ 按位异或\n   */\n  parseBitwiseOrExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseAndExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '^')) {\n      this.parseBitwiseAndExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, '^'))\n    }\n  }\n\n  /**\n   * 解析 & 按位与\n   */\n  parseBitwiseAndExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseEqualExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '&')) {\n      this.parseBitwiseAndExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, '&'))\n    }\n  }\n\n  /**\n   * 解析判等 ['==', '===', '!=', '!==']\n   */\n  parseEqualExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseCompareExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['==', '===', '!=', '!=='])) {\n      var op = this.current\n      this.parseCompareExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析比较运算符 ['<', '<=', '>=', '>']\n   */\n  parseCompareExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseInOrAtExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['<', '<=', '>=', '>'])) {\n      var op = this.current\n      this.parseInOrAtExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n  * 解析或运算符 ['||', '@'] @待补位\n  */\n  parseInOrAtExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseMoveExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['in'/** ,\"@\" */])) {\n      var op = this.current\n      this.parseBitwiseMoveExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析按位移 [\">>\", \">>>\", \"<<\"]\n   */\n  parseBitwiseMoveExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseAddOrSubExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\">>\", \">>>\", \"<<\"])) {\n      var op = this.current\n      this.parseAddOrSubExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析加减法 + -\n   */\n  parseAddOrSubExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseMulOrDivExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\"+\", \"-\"])) {\n      var op = this.current\n      this.parseMulOrDivExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析乘除取模 * / %\n   */\n  parseMulOrDivExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseUnaryExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\"*\", \"/\", \"%\"])) {\n      var op = this.current\n      this.parseUnaryExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析一元运算符 [+, ++, +, -, !, ~, cos, tan, typeof]\n   */\n  parseUnaryExpression = (exprInstr: TypeInstruction[]): void => {\n    this.temporarySaved();\n    if (this.accept(TOKEN_OPERATOR, isUnaryOpeator)) {// 内置函数调用\n      if (unarySymbolMapReg.test(this.current.value)) { // +, ++, +, -, !, ~,\n        const op = this.current\n        this.parseUnaryExpression(exprInstr); // 兼容 ++-1\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      } else if (this.accept(TOKEN_PAREN, '(', false)) { // typeof(\n        const op = this.current\n        this.accept(TOKEN_PAREN, '(')\n        this.parseConditionalExpression(exprInstr);\n        this.expect(TOKEN_PAREN, ')')\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      } else if (\n        [TOKEN_COMMA, TOKEN_SEMICOLON, TOKEN_END].indexOf(this.nextToken.type) !== -1 || // typeof, typeof; typeof\n        (this.nextToken.type === TOKEN_PAREN && this.nextToken.value === ')') // typeof)\n      ) {\n        this.restore();\n        this.parseField(exprInstr);\n      } else { // 需要支持typeof 1 ; typeof typeof 1 === typeof(typeof(1)) === typeof(typeof 1);\n        const op = this.current\n        this.parseUnaryExpression(exprInstr) // 外置函数 || 内声明函数\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      }\n    } else {\n      this.parseOuterFunctionCallExpression(exprInstr) // 外置函数 || 内声明函数\n    }\n  }\n\n  /**\n   * 外置函数调用\n   */\n  parseOuterFunctionCallExpression = (exprInstr: TypeInstruction[]) => {\n    this.parseMemberAccessExpression(exprInstr)\n    if (this.current.type === TOKEN_NAME && this.accept(TOKEN_PAREN, '(', false)) {\n      this.parseArguments(exprInstr)\n    }\n  }\n\n  /**\n   * 解析内置函数调用\n   */\n  // parsePersetFuncCallExpression = (exprInstr: TypeInstruction[]): void => {\n  //     this.parseMemberAccessExpression(exprInstr); // a.b()\n  //     this.parseArguments(exprInstr)\n  // }\n\n  /**\n   * 解析调用函数的实参\n   */\n  parseArguments = (exprInstr: TypeInstruction[]): void => {\n    while (this.accept(TOKEN_PAREN, '(')) {\n      if (this.accept(TOKEN_PAREN, ')')) {\n        // 立即调用\n        exprInstr.push(new Instruction(INSTR_FUNCALL, 0)) // 参数长度 \n      } else {\n        let count = 0\n        while (!this.accept(TOKEN_PAREN, ')')) {\n          do {\n            this.parseConditionalExpression(exprInstr);\n            count++;\n          } while (this.accept(TOKEN_COMMA))\n        }\n        exprInstr.push(new Instruction(INSTR_FUNCALL, count))\n      }\n    }\n  }\n\n  /**\n   * 解析成员访问符 . []\n   */\n  parseMemberAccessExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseField(exprInstr);\n    const refPath = [];\n    const currentItem = exprInstr[exprInstr.length - 1];\n    if(currentItem && currentItem.type === INSTR_NAME) {\n      refPath.push(currentItem.value) // 尝试最后一个是否是NAME变量\n    }\n    while (\n      this.accept(TOKEN_OPERATOR, '.') ||\n      (contains([TOKEN_SQUARE, TOKEN_NAME], this.current.type) && this.accept(TOKEN_SQUARE, '['))) {\n        \n      if (!this.ceval.getOptions().allowMemberAccess) {\n        throw new Error(`options \"allowMemberAccess\": You have disabled member access and cannot use syntax such as \"a.b\" \"a['b']\"`)\n      }\n      if (this.current.value === '.') {\n        this.expect(TOKEN_NAME); // a.name ✔️  a.1×\n        refPath.push(new Instruction(INSTR_PLAIN, this.current.value))\n      } else if (this.current.value === '[' && (this.accept(TOKEN_NAME) || this.accept(TOKEN_NUMBER) || this.accept(TOKEN_STRING))) {\n        refPath.push(new Instruction(this.current.type === TOKEN_NAME ? INSTR_NAME : INSTR_PLAIN, this.current.value))\n        this.expect(TOKEN_SQUARE, ']')\n      }\n    }\n    if(refPath.length > 1) {\n      exprInstr.pop(); // 拿到全部引用\n      exprInstr.push(new Instruction(INSTR_MEMBER, refPath))\n    }\n  }\n\n\n  /**\n   * 解析字面值、字段值 number||string||operator(typeof cos tan)||[1,2,3]|| {a:1,b:{}} || (expression) || function abs() {}\n   */\n  parseField = (exprInstr: TypeInstruction[]): void => {\n    if (this.accept(TOKEN_OPERATOR, isUnaryOpeator)) {\n      // 内置前缀运算符 cos tan - +\n      exprInstr.push(new Instruction(INSTR_OPERA1, this.current.value));\n    } else if (this.accept(TOKEN_NAME)) {\n      // 变量名称\n      if(this.accept(TOKEN_OPERATOR, '=', false)) {// 赋值操作，避免转成TOKEN_NAME去取值了。\n        exprInstr.push(new Instruction(INSTR_VARNAME, this.current.value));\n      } else {\n        exprInstr.push(new Instruction(INSTR_NAME, this.current.value));\n      }\n    } else if (this.accept(TOKEN_NUMBER)) {\n      // 数字类型\n      exprInstr.push(new Instruction(INSTR_NUMBER, this.current.value));\n    } else if (this.accept(TOKEN_STRING)) {\n      // 字符串类型 \\\"name\\\"\n      exprInstr.push(new Instruction(INSTR_PLAIN, this.current.value));\n    } else if (this.accept(TOKEN_PAREN, '(')) {\n      // 圆括号，调用 或 表达式(a=1)\n      this.parseExpression(exprInstr);\n      this.expect(TOKEN_PAREN, ')');\n    } else if (this.accept(TOKEN_SQUARE, '[')) {\n      //  数组字面量\n      this.parseArrayLiteralDeclaration(exprInstr)\n    } else if (this.accept(TOKEN_CURLY, '{', false)) {\n      // Object字面量声明\n      this.parseObjectLiteralDeclaration(exprInstr)\n    } else if (this.accept(TOKEN_VAR, ['const', 'var', 'let'])) {\n      // 赋值表达式 需要收集ident 和 variableName 避免variableName识别成varName 引发error\n      const identifier = this.current\n      this.expect(TOKEN_NAME)\n      exprInstr.push(new Instruction(INSTR_VARNAME, this.current.value));\n      exprInstr.push(new Instruction(INSTR_VAR, identifier.value))\n    } else if (this.accept(TOKEN_FUNC, undefined, false)) {\n      this.parseFunctionDefinedDeclaration(exprInstr);\n    } else if (this.accept(TOKEN_SEMICOLON)) {\n      // empty, fault tolerant \n    } else {\n      throw new Error('unexpected ' + this.nextToken);\n    }\n  }\n\n  /**\n   * 解析对象字面量 { a: 1, b: 2, c: {}}\n   */\n  parseArrayLiteralDeclaration = (exprInstr: TypeInstruction[]) => {\n    // Array字面量声明 TODO: 需要和 obj['a'] 做区分\n    const instr = []\n    if (this.accept(TOKEN_SQUARE, ']')) { // []\n      exprInstr.push(new Instruction(INSTR_ARRAY, instr))\n      return\n    }\n    this.parseExpression(instr)\n    this.expect(TOKEN_SQUARE, ']')\n    exprInstr.push(new Instruction(INSTR_ARRAY, instr))\n  }\n\n  /**\n   * 解析对象字面量 { a: 1, b: 2, c: {}}\n   */\n  parseObjectLiteralDeclaration = (exprInstr: TypeInstruction[]) => {\n    while (this.accept(TOKEN_CURLY, '{')) {\n      const instr = {}\n      if (this.accept(TOKEN_CURLY, '}')) { // {}\n        exprInstr.push(new Instruction(INSTR_OBJECT, instr))\n        return\n      }\n      while (this.accept(TOKEN_NAME) || this.accept(TOKEN_NUMBER) || this.accept(TOKEN_STRING)) {\n        const key = this.current.value\n        this.expect(TOKEN_OPERATOR, ':');\n        instr[key] = [];\n        if (this.accept(TOKEN_CURLY, '{', false)) {\n          this.parseObjectLiteralDeclaration(instr[key])\n        } else {\n          this.parseConditionalExpression(instr[key]);\n        }\n        this.accept(TOKEN_COMMA, ',');\n      }\n      this.expect(TOKEN_CURLY, '}');\n      this.accept(TOKEN_SEMICOLON, ';')\n      exprInstr.push(new Instruction(INSTR_OBJECT, instr))\n    }\n  }\n\n  /**\n   * 解析函数声明\n   */\n  parseFunctionDefinedDeclaration = (expreInstr: TypeInstruction[]) => {\n    while (this.accept(TOKEN_FUNC)) {\n      if (this.accept(TOKEN_NAME)) { // function fn(){}\n        const funcName = this.current.value;\n        const instr = []; // 参数 与 函数体\n        if (this.accept(TOKEN_PAREN, '(')) {\n          do {\n            this.parseField(instr); // TODO fn(a=1) 待兼容\n          } while (this.accept(TOKEN_COMMA))\n          this.expect(TOKEN_PAREN, ')')\n        }\n        this.parseFunctionBodyExpression(instr)\n        expreInstr.push(new Instruction(INSTR_FUNCDEF, instr))\n        expreInstr.push(new Instruction(INSTR_FUNCDEF, funcName))\n      }\n    }\n  }\n\n  /**\n   * 解析函数体, 花括号 { }, 应该视作一个新的作用域. // TODO: 可作为单独作用域体\n   */\n  parseFunctionBodyExpression = (exprInstr: TypeInstruction[]) => {\n    if (this.accept(TOKEN_CURLY, '{')) {\n      const instr = [];\n      do {\n        this.parseExpression(instr)\n      } while (this.accept(TOKEN_SEMICOLON, ';') && !this.accept(TOKEN_CURLY, '}', false))\n      if(this.current.type !== TOKEN_SEMICOLON) {\n        throw new SyntaxError(`Function parse error: Function body each line must end with semicolon ';'`)\n      }\n      this.expect(TOKEN_CURLY, '}')\n      this.accept(TOKEN_SEMICOLON, ';')\n      exprInstr.push(new Instruction(INSTR_EXPRE, instr))\n    }\n  }\n\n  /**\n   * 增加提示\n   */\n  printLog = (msg: string, tip: string, c: Console[\"log\" | \"error\" | \"warn\"] = console.log) => {\n    c(`${msg} %c${tip}`, `margin: 0 .5em;text-decoration-line: underline;text-decoration-color: red;text-decoration-style: wavy;line-height: 2em;color: red;`)\n  }\n}","/** @desc javascript保留字 */\nexport const jsWord = {\n  \"abstract\": false,\n  \"arguments\": false,\n  \"boolean\": false,\n  \"break\": false,\n  \"byte\": false,\n  \"case\": false,\n  \"catch\": false,\n  \"char\": false,\n  \"class\": false,\n  \"const\": false,\n  \"continue\": false,\n  \"debugger\": false,\n  \"default\": false,\n  \"delete\": false,\n  \"do\": false,\n  \"double\": false,\n  \"else\": false,\n  \"enum\": false,\n  \"eval\": false,\n  \"export\": false,\n  \"extends\": false,\n  \"final\": false,\n  \"finally\": false,\n  \"float\": false,\n  \"for\": false,\n  \"function\": false,\n  \"goto\": false,\n  \"if\": false,\n  \"implements\": false,\n  \"import\": false,\n  \"in\": true,\n  \"instanceof\": false,\n  \"int\": false,\n  \"interface\": false,\n  \"let\": false,\n  \"long\": false,\n  \"native\": false,\n  \"new\": false,\n  \"null\": false,\n  \"package\": false,\n  \"private\": false,\n  \"protected\": false,\n  \"public\": false,\n  \"return\": true,\n  \"short\": false,\n  \"static\": false,\n  \"super\": false,\n  \"switch\": false,\n  \"synchronized\": false,\n  \"this\": false,\n  \"throw\": false,\n  \"throws\": false,\n  \"transient\": false,\n  \"try\": false,\n  \"typeof\": false,\n  \"var\": false,\n  \"void\": false,\n  \"volatile\": false,\n  \"while\": false,\n  \"with\": false,\n  \"yield\": false\n}\n\n/** @desc JavaScript属性方法保留字 */\nexport const jsAttr = {\n  \"Array\": false, \n  \"Date\": false, \n  \"eval\": false, \n  \"function\": false, \n  \"hasOwnProperty\": false,\n  \"Infinity\": false, \n  \"isFinite\": false, \n  \"isNaN\": false, \n  \"isPrototypeOf\": false, \n  \"length\": false,\n  \"Math\": false, \n  \"NaN\": true, \n  \"name\": false, \n  \"Number\": false, \n  \"Object\": false,\n  \"prototype\": false, \n  \"String\": false, \n  \"toString\": false, \n  \"undefined\": false, \n  \"valueOf\": false, \n}\n\n/** @desc window保留字 */\nexport const windowWord = {\n  \"alert\": false, \n  \"all\": false, \n  \"anchor\": false, \n  \"anchors\": false, \n  \"area\": false,\n  \"assign\": false, \n  \"blur\": false, \n  \"button\": false, \n  \"checkbox\": false, \n  \"clearInterval\": false,\n  \"clearTimeout\": false, \n  \"clientInformation\": false, \n  \"close\": false, \n  \"closed\": false, \n  \"confirm\": false,\n  \"constructor\": false, \n  \"crypto\": false, \n  \"decodeURI\": false, \n  \"decodeURIComponent\": false, \n  \"defaultStatus\": false,\n  \"document\": false, \n  \"element\": false, \n  \"elements\": false, \n  \"embed\": false, \n  \"embeds\": false,\n  \"encodeURI\": false, \n  \"encodeURIComponent\": false, \n  \"escape\": false, \n  \"event\": false, \n  \"fileUpload\": false,\n  \"focus\": false, \n  \"form\": false, \n  \"forms\": false, \n  \"frame\": false, \n  \"innerHeight\": false,\n  \"innerWidth\": false, \n  \"layer\": false, \n  \"layers\": false, \n  \"link\": false, \n  \"location\": false,\n  \"mimeTypes\": false, \n  \"navigate\": false, \n  \"navigator\": false, \n  \"frames\": false, \n  \"frameRate\": false,\n  \"hidden\": false, \n  \"history\": false, \n  \"image\": false, \n  \"images\": false, \n  \"offscreenBuffering\": false,\n  \"open\": false, \n  \"opener\": false, \n  \"option\": false, \n  \"outerHeight\": false, \n  \"outerWidth\": false,\n  \"packages\": false, \n  \"pageXOffset\": false, \n  \"pageYOffset\": false, \n  \"parent\": false, \n  \"parseFloat\": false,\n  \"parseInt\": false, \n  \"password\": false, \n  \"pkcs11\": false, \n  \"plugin\": false, \n  \"prompt\": false,\n  \"propertyIsEnum\": false, \n  \"radio\": false, \n  \"reset\": false, \n  \"screenX\": false, \n  \"screenY\": false,\n  \"scroll\": false, \n  \"secure\": false, \n  \"select\": false, \n  \"self\": false, \n  \"setInterval\": false,\n  \"setTimeout\": false, \n  \"status\": false, \n  \"submit\": false, \n  \"taint\": false, \n  \"text\": false,\n  \"textarea\": false, \n  \"top\": false, \n  \"unescape\": false, \n  \"untaint\": false, \n  \"window\": false\n}","import Token, { TOKEN_END, TOKEN_STRING, TOKEN_COMMA, TOKEN_FUNC, TOKEN_CURLY, TOKEN_PAREN, TOKEN_SEMICOLON, TOKEN_VAR, TOKEN_NUMBER, TOKEN_NAME, TOKEN_OPERATOR, TOKEN_SQUARE } from './token';\nimport { TypeToken, TypeCeval } from './interface';\nimport { whitespaceReg, commentReg, stringReg, constsMapReg, number2bitReg, number8bitReg, number10bitReg, number16bitReg, variableReg, operatorReg, unaryMapReg, booleanReg, execFactoryReg, number010bitReg, stringGreedyReg, numberEbitReg } from './utils/regExp';\nimport { jsWord, jsAttr } from './utils/reservedWord';\nimport { contains, isPalindrome, filterUndefine } from './utils/index';\n\n/**\n * 语法解析\n * @class TokenStream\n */\nexport default class TokenStream {\n  // 当前指针下标\n  pos = 0;\n\n  // 当前解析character\n  current: null | TypeToken = null;\n\n  // 暂存指针\n  savedPosition = 0;\n\n  // 暂存解析character，在某些情况下做预判比如, cos是函数，cos() || map(cos) “cos)” 可能被函数parser判定为语法错误\n  savedCurrent: null | TypeToken = null;\n\n  // eslint-disable-next-line\n  constructor(public ceval: TypeCeval, public expression: string) {}\n\n  /**\n   * @desc 获取nextToken，适用语法前置校验\n   * @memberof TokenStream\n   */\n  checkNextAccessGrammar = (): TypeToken => {\n    this.temporarySaved();\n    const next = this.next();\n    this.restore();\n    return next\n  }\n\n  /**\n   * @desc 某些情况下做正则优化，比如 operator 至多3位，所以截取3位再匹配\n   * @param len 获取的长度\n   * @param offset 位移\n   * @see charAt与substr性能对比 https://jsperf.com/substr-or-charat\n   * @memberof TokenStream\n   */\n  getSomeCode = (len = 1, offset = 0): string => {\n    const start = offset + this.pos\n    const { length } = this.expression;\n    // debugger\n    return this.expression.substr(start, (start + len) > length ? length - start : len)\n  }\n\n  /**\n   * @desc 获取首个单词\n   * @memberof TokenStream\n   */\n  getFirstWord = (): string => {\n    const result = this.expression.substr(this.pos).match(/\\b\\w*\\b/)\n    return result ? result[0] : ''\n  }\n\n  /**\n   * 创建新的fieldType实例\n   * @memberof TokenStream\n   */\n  newToken = (type: string, value: number | string, pos?: number): TypeToken => {\n    return new Token(type, value, pos != null ? pos : this.pos);\n  }\n\n  /**\n   * 解析下一个 field\n   * @memberof TokenStream\n   */\n  next = (): TypeToken => {\n    if (!this.expression.length) {\n      return this.newToken(TOKEN_NAME, \"undefined\")\n    }\n    if (this.pos >= this.expression.length) {\n      return this.newToken(TOKEN_END, 'END');\n    }\n\n    if (this.isWhiteSpace() || this.isComment()) {\n      return this.next()\n    } else if (\n      this.isNumber() ||\n      this.isString() ||\n      this.isBoolean() ||\n      this.isParenthesis() ||\n      this.isComma() ||\n      this.isOperator() ||\n      this.isSemicolon() ||\n      this.isConst() ||\n      this.isVariable() ||\n      this.isFunctionDefined() ||\n      this.isName()\n    ) {\n      return this.current\n    } else {\n      this.parseError(`unknown character: ${this.expression.charAt(this.pos)}`, SyntaxError)\n    }\n  }\n\n  temporarySaved = (): void => {\n    this.savedPosition = this.pos;\n    this.savedCurrent = this.current;\n  }\n\n  restore = (): void => {\n    this.pos = this.savedPosition;\n    this.current = this.savedCurrent\n  }\n\n  /**\n   * 过滤空格 \\t \\r \\n\n   * @memberof TokenStream\n   */\n  isWhiteSpace = (): boolean => {\n    const matchWS = whitespaceReg.exec(this.getSomeCode())\n    while (matchWS && matchWS[1]) {\n      this.pos++\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 过滤注释 /*  *\\/\n   * @memberof TokenStream\n   */\n  isComment = (): boolean => {\n    const prefixCm = this.getSomeCode(2);\n    let matchResult: string | undefined\n    if (prefixCm === '/*') {\n      matchResult = execFactoryReg(commentReg, this.getSomeCode(Infinity))\n    } else if(prefixCm === '//') { // comment break line\n      matchResult = execFactoryReg(/^(\\/\\/.*\\n?)/, this.getSomeCode(Infinity));\n    }\n\n    if (matchResult) {\n      this.pos += matchResult.length +(prefixCm === '/*'? (2 + 2):0); // /*matchResult*/\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 过滤空格 \\t \\r \\n\n   * @memberof TokenStream\n   */\n  isBoolean = (): boolean => {\n    const matchWS = booleanReg.exec(this.getSomeCode())\n    while (matchWS && matchWS[1]) {\n      this.pos++\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 申明变量 TODO:support\n   * @memberof TokenStream\n   */\n  isVariable = (): boolean => {\n    const word = this.getFirstWord()\n    if (contains(['const', 'var', 'let'], word)) {\n      this.pos += word.length;\n      this.current = this.newToken(TOKEN_VAR, word)\n      const nextToken = this.checkNextAccessGrammar()\n\n      if (nextToken.type !== TOKEN_NAME) {\n        throw new Error(`${word} ${nextToken.value} : This syntax Not as expected, should be \"${TOKEN_NAME}\", but is \"${nextToken}\"`)\n      } else if(contains(this.ceval.consts, nextToken.value)){\n        throw new SyntaxError(`SyntaxError:  Unexpected token '${nextToken.value}', it has been stated in consts.`)\n      }\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 数字 \n   * @see 说明 需要考虑到 2进制0b10100 === 8进制024 === 10进制20 === 16进制0x14 === 10e0 === 20.000\n   * @memberof TokenStream\n   */\n  isNumber = (): boolean => {\n    const first = this.getSomeCode()\n    let number: string | undefined\n    let bit: number\n    const expr = this.getSomeCode(this.expression.length - this.pos)\n\n    if ((/\\d|\\./.test(first) === false) || (first === '.' && /\\.\\d/.test(this.getSomeCode(2)) === false)) return false\n\n    const [n] = expr.match(/^(0(x|b)+[0-9a-zA-Z]{1,})|(^0?\\d*(\\.\\d+)?)/); // 019 可能会被8进制拦截掉01， 所以必须要做^$\n    number10bitReg.lastIndex = 0;\n    if (first === '0' && n.length > 1 && !(/^0\\.\\d/.test(n))) { // 0.x 不是进制数\n      if (contains(['b', 'x'], this.getSomeCode(1, 1)) && this.getSomeCode(1, n.length) === '.') {\n        // 0b0101.1 0xaf.1 ❌\n        // 099.1 属于十进制 ✅\n        this.parseError(`number '${n}' cannot is a floating point number, but actual is: '${n}${this.getSomeCode(3, n.length)}'`, SyntaxError)\n        return false\n      }\n\n      if (number2bitReg.test(n)) {\n        // 2进制\n        // @see 0b01 0b1110\n        number = execFactoryReg(number2bitReg, n)\n        bit = number === undefined ? undefined : 2\n      } else if (number8bitReg.test(n)) {\n        // 8进制\n        // @see 012 || 077 ✅ \b\n        // @warn 080 || 079 ❌都是十进制  并非8进制\n        number = execFactoryReg(number8bitReg, n)\n        bit = number === undefined ? undefined : 8\n      } else if (number16bitReg.test(n)) {\n        // 16进制 \n        // @see 0xadf\n        number = execFactoryReg(number16bitReg, n)\n        bit = number === undefined ? undefined : 16\n      } else if (number010bitReg.test(n)) {\n        // 0开头十进制 \n        // @see 079 || 080  ✅\n        // @warn 03.1 || 00.1 || 00.  ❌ \n        number = execFactoryReg(number010bitReg, n)\n        bit = number === undefined ? undefined : 10\n      } else {\n        this.parseError('number bitbase parser error', SyntaxError)\n        return false\n      }\n      this.pos += number.length\n      if (number !== undefined && !this.ceval.getOptions().endableBitNumber) { // 给出准确的warning \n        throw new Error(`options \"endableBitNumber\": You have disabled bitbase number parsing, Not allowed ${number}`)\n      }\n    } else if(numberEbitReg.test(expr)) { // 科学计数法\n      numberEbitReg.lastIndex = 0;\n      const [, match, base, times] = numberEbitReg.exec(expr);\n      this.pos += (match.length || (base.length + times.length + 1));\n      number = match || (Number(base) * Math.pow(10, Number(times))).toString()\n      bit = 10;\n    }else if (number10bitReg.test(expr)) { // 十进制\n      // 100 || 100.1 || 0.1 || .100 || .0  ✅ \n      // parseFloat是支持 0100.1 的。\n      number = execFactoryReg(number10bitReg, expr)\n      bit = number === undefined ? undefined : 10\n      this.pos += number.length\n    } else {\n      return false\n    }\n\n    if (bit === 10) {\n      this.current = this.newToken(TOKEN_NUMBER, parseFloat(number))\n    } else {\n      this.current = this.newToken(TOKEN_NUMBER, parseInt(number.replace('0b', '').replace('0x', ''), bit))\n    }\n    return true\n  }\n\n  /**\n   * 字符串\n   * @see '' \\'\\' \\\"\\\" \\\"\\'\\'\\\"\n   * @memberof TokenStream\n   */\n  isString = (): boolean => {\n    const first = this.getSomeCode()\n    const expr = this.getSomeCode(Infinity)\n    let matchString: RegExpExecArray | undefined\n    let strContent: string | undefined\n    if (first === '\\\"' || first === '\\'') {\n      stringGreedyReg.lastIndex = 0;\n        // 一种情况是需要贪婪匹配 \\'\\'a\\'\\', 判断是否需要贪婪匹配\n      matchString = stringGreedyReg.exec(expr)\n      strContent = filterUndefine(matchString[1], matchString[2])\n      if (!isPalindrome(strContent)) {\n        // 不属于回文字符串则需要重新做惰性匹配\n        // 另一种则需要惰性 \"'a', 'b'\" => \"a\"\n        stringReg.lastIndex = 0;\n        matchString = stringReg.exec(expr);\n        strContent = filterUndefine(matchString[1], matchString[2])\n      }\n\n      if (strContent !== undefined) {\n        this.current = this.newToken(TOKEN_STRING, strContent, this.pos)\n        this.pos += (strContent.length + first.length * 2); // \"\" 是没有长度的，会导致Token指针一直处于 \"\" \n        return true\n      }\n    }\n\n    return false\n  }\n\n  isFunctionDefined = (): boolean => {\n    const word = this.getFirstWord();\n    if(word === 'function') {\n      // TODO: 初期只支持 第一种, 同时支持 function fn() {} || const a = () => {} || const b = function(){}\n      this.current = this.newToken(TOKEN_FUNC, undefined);\n      this.pos+=word.length\n      const nextToken = this.checkNextAccessGrammar(); \n      if(nextToken.type !== TOKEN_NAME) {\n        this.parseError('function definition should have function name')\n        return false\n      }\n      return true;\n    }\n    return false\n  }\n  \n  /**\n   * 变量，可能是名称\n   * @see 遵循变量申明规范 可以以 $_ 开头，其他可以是 $_数字字母 ，排除保留字\n   * @memberof TokenStream\n   */\n  isName = (): boolean => {\n    const first = this.getSomeCode()\n    let result\n    if (first === '_' || first === '$' || /^[a-zA-Z]/.test(first)) {\n      variableReg.lastIndex = 0\n      result = variableReg.exec(this.getSomeCode(Infinity))\n    }\n\n    if (result === undefined || result === null || typeof result[1] !== \"string\") {\n      return false\n    }\n\n    [, result] = result;\n\n    if (jsWord[result] === false) {\n      // 检测到保留字\n      this.parseError(`parser an reserved word: ${result}`)\n      return false\n    }\n\n    if (jsAttr[result] === false) {\n      // 检测到window属性 TODO: 应该命中 window.xxx\n      this.parseError(`parser an window native attributes or methods: ${result}`)\n      return false\n    }\n\n    this.pos += result.length\n    this.current = this.newToken(TOKEN_NAME, result)\n    return true\n  }\n\n  /**\n   * 内置常量\n   * @see const 例如 true false PI undefined null\n   * @memberof TokenStream\n   */\n  isConst = (): boolean => {\n    constsMapReg.lastIndex = 0;\n    const result = constsMapReg.exec(this.getSomeCode(Infinity))\n\n    if (result && result[1]) {\n      this.current = this.newToken(TOKEN_NAME, result[1])\n      this.pos += result[1].length;\n      const constKey = this.checkNextAccessGrammar();\n      // 检查是否是const常量赋值\n      if(constKey.type === TOKEN_OPERATOR && constKey.value === '=') {\n        this.parseError(`parser error: consts of ${this.current.value} can not assignment;`, SyntaxError)\n      }\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * 分号\n   * @see ;\n   * @memberof TokenStream\n   */\n  isSemicolon = (): boolean => {\n    var first = this.getSomeCode();\n    if (first === ';') {\n      this.current = this.newToken(TOKEN_SEMICOLON, ';');\n      this.pos++;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * 逗号,\n   * @see ,\n   * @memberof TokenStream\n   */\n  isComma = (): boolean => {\n    var first = this.getSomeCode();\n    if (first === ',') {\n      this.current = this.newToken(TOKEN_COMMA, ',');\n      this.pos++;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * 圆、方括号\n   * @see ;\n   * @memberof TokenStream\n   */\n  isParenthesis = (): boolean => {\n    var first = this.getSomeCode();\n    if (contains(['(', ')'], first)) {\n      this.current = this.newToken(TOKEN_PAREN, first);\n    } else if (contains(['[', ']'], first)) {\n      this.current = this.newToken(TOKEN_SQUARE, first);\n    } else if (contains(['{', '}'], first)) {\n      this.current = this.newToken(TOKEN_CURLY, first);\n    } else {\n      return false\n    }\n    this.pos++;\n    return true;\n  };\n\n  /**\n   * 判断是否操作符 \n   * @see 操作符 + - * / || % ^ ? : . > < = >= <= | == === != !== in\n   * @memberof TokenStream\n   */\n  isOperator = (): boolean => {\n    const str = this.getSomeCode(Infinity);\n    let result: string | undefined\n    if (operatorReg.test(str)) {\n      result = execFactoryReg(operatorReg, str)\n    } else if (unaryMapReg.test(str)) {\n      result = execFactoryReg(unaryMapReg, str)\n    }\n    \n    if (!result) return false\n\n    if(this.ceval.getOptions().endableOperators === false) {\n      throw new Error(`options \"endableOperators\": You disabled the operator, Therefore, \"${result}\" it can not be used`)\n    }\n    result = result.replace(/\\s/g, '')\n    this.pos += result.length\n    this.current = this.newToken(TOKEN_OPERATOR, result)\n    return true\n  }\n\n  /**\n   * 获取当前character定位\n   * @memberof TokenStream\n   */\n  getCoordinates = (): { line: number, column: number } => {\n    let line = 0;\n    let column = 0;\n    let index = -1;\n    \n    do {\n      line++;\n      column = this.pos - index;\n      index += 1\n      index += this.expression.substr(index).indexOf('\\n'); // 从每一行第一位开始寻找下一个换行符\n    } while (index >= 0 && index < this.pos && line < this.pos)\n    return {\n      line,\n      column\n    };\n  };\n\n  /**\n   * 解析出错\n   * @memberof TokenStream\n   */\n  parseError = (msg: string, ErrorType: ErrorConstructor | SyntaxErrorConstructor | TypeErrorConstructor = Error): never => {\n    var coords = this.getCoordinates();\n    throw new ErrorType('parse error [' + coords.line + ':' + coords.column + '] => ' + msg);\n  };\n\n}","import Instruction, { INSTR_EXPRE, INSTR_FUNCDEF, INSTR_EXECUTBODY, INSTR_VARNAME, INSTR_NAME, INSTR_OBJECT, INSTR_ARRAY, INSTR_FUNCALL, INSTR_MEMBER, INSTR_NUMBER, INSTR_VAR, INSTR_OPERA2, INSTR_PLAIN, INSTR_OPERA3, INSTR_OPERA1 } from './instruction';\nimport Ceval from './index';\nimport { hasAttribute, mapToObject, merge, someCondition, getReference, Reference } from './utils/index';\n\n/**\n * 运算\n * @export calculation\n * @param {Instruction[]} tokens    TokenQueue\n * @param {object} [values={}]      数据池\n * @param {Ceval} ceval             instance of eval\n * @param {boolean} [statis=false]  true全量返回 默认false\n * @param {object} [scope={}]       作用域\n * @returns result or result[]\n */\nexport default function calculation(tokens: Instruction<any>[], values = Object.create(null), ceval: Ceval, statis = false, scope = Object.create(null)) {\n  // if (window && window.name) {\n  //  console.group('calclation Dev')\n  //   console.log('tokens: ', tokens);\n  //   console.log('values', values)\n  //   console.log('scope', scope)\n  //  console.groupEnd()\n  // }\n  const options = ceval.getOptions();\n  const { unaryOps, binaryOps, ternaryOps } = ceval\n  const stack = [];\n  const { length } = tokens;\n  let n1, n2, n3;\n  let fn: undefined | Function | Instruction<CustomFunc>\n  for (let i = 0; i < length; i++) {\n    const item = tokens[i];\n    const { type, value } = item || {};\n\n    if (!type) {\n      stack.push(item)\n      continue\n    }\n    switch(type) {\n      case INSTR_NUMBER: \n      case INSTR_PLAIN:\n      case INSTR_VARNAME: {\n        stack.push(value);\n        break\n      }\n      case INSTR_NAME: {\n        // 变量名称，范围作用域有functions consts values _scope 后者优先\n        if (hasAttribute(scope, value)) {\n          // scope,作用域\n          stack.push(scope[value])\n        } else if (hasAttribute(values, value)) {\n          // customVal\n          stack.push(values[value])\n        } else if (hasAttribute(ceval.consts, value)) {\n          // 常量\n          stack.push(ceval.consts[value])\n        } else if(hasAttribute(ceval.functions, value)) {\n          // 内置函数\n          stack.push(ceval.functions[value])\n        } else {\n          throw new Error(`${value} is not defined in values or consts`)\n        }\n        break\n      }\n      case INSTR_OPERA1: {\n        if(stack.length === 0) break;\n        // 一元运算，需要一个操作数\n        [n1] = stack.splice(-1, 1);\n        fn = specifyAttr<Function>(value, [values, unaryOps], options.allowOperatorsCovered)\n        \n        stack.push(fn(n1));\n        // 当操作符是return 时，终止该运算循环\n        if(value === 'return') {\n          i = length\n        }\n        break\n      }\n      case INSTR_OPERA2: { // 二元运算，需要有两个操作数\n        if(stack.length < 2) break;\n        [n1, n2] = stack.splice(-2, 2)\n          fn = specifyAttr<Function>(value, [values, binaryOps], options.allowOperatorsCovered)\n        if (value === '&&') { // 1&&0&&3可能是连续的\n          stack.push(fn(n1, calculation([n2], values, ceval, statis, scope), false)); // true && true && false\n        } else if (value === '=') {\n          // 写操作分为属性赋值和引用赋值\n          if(n1 instanceof Reference) { // left hide 为引用\n            n1.setValue(n2);\n            n1.destory();\n          } else {\n            someCondition(hasAttribute(scope, n1), hasAttribute(values, n1), `${n1} is not define in values or current scope, if you are declaring a new variable, please add var, const or let operator`)\n            fn(n1, n2, hasAttribute(scope, n1) ? scope : values)\n          // 如果当前作用域含有该属性，作用域优先\n          }\n        } else {\n          stack.push(fn(n1, (typeof n2 === 'string' || typeof n2 === 'number') ? n2: calculation([n2], values, ceval, statis, scope), options));\n        }\n        break\n      }\n      case INSTR_OPERA3: { // 三元运算，需要有三个操作数\n        if(stack.length < 3) break;\n        [n1, n2, n3] = stack.splice(-3, 3)\n        fn = specifyAttr<Function>(value, [values, ternaryOps], options.allowOperatorsCovered)\n        stack.push(fn(n1, n2, n3));\n        break\n      }\n      case INSTR_EXPRE: { // 表达式\n        stack.push(calculation(item.value, values, ceval, statis, scope))\n        break;\n      }\n      case INSTR_MEMBER: { // 成员访问\n        // 有可能是读，也有可能是写；\n        const nextItem = tokens[i+2]; // 解析顺序 INSTR_MEMBER => INSTR_EXPRE => INSTR_OP2\n        const keys = calculation(value, values, ceval, true, scope)\n        const ref = getReference(keys, scope, values)\n        \n        if(nextItem && nextItem.type === INSTR_OPERA2 && nextItem.value === '=') {\n          // 写操作, JavaScript是拿不到引用的，push到stack，等待引用赋值\n          stack.push(ref)\n        } else {\n          stack.push(ref.getValue())\n          ref.destory();\n        }\n        \n        break\n      }\n      case INSTR_ARRAY: { // 数组字面量\n        stack.push(calculation(value, values, ceval, true, scope))\n        break\n      }\n      case INSTR_OBJECT: { // 对象字面量\n        const instr = Object.create(null)\n        Object.keys(value).forEach(key => {\n          instr[key] = calculation(value[key], values, ceval, statis,scope)\n        })\n        stack.push(instr)\n        break\n      }\n      case INSTR_VAR: { // 赋值语句\n        [n1, n2] = stack.splice(-2, 2)\n        switch (value) {\n          case 'let':\n          case 'const': {\n            // let const的行为待定义, let 和 const 应该挂载到作用域上，而var 可以赋给 values \n            // TODO: 需要判定assgin给scope还是values\n            if (hasAttribute(scope, n1)) {\n              console.warn(`${n1} already statement in consts or scope`)\n            }\n            scope[n1] = n2;\n            break\n          }\n          case 'var': {\n            values[n1] = n2; \n            break\n          }\n          default: {\n            console.warn('Unexpected statement identifier')\n            break;\n          }\n        }\n        break\n      }\n      case INSTR_FUNCALL: { // 自声明函数调用，区分是外部函数还是内声明函数\n        const args = stack.splice(-value, value);\n        fn = stack.pop();\n        // if(args.length !== value) {} // TODO: 参数不够的情况 warning\n        if (typeof fn === 'function') {\n          // 外置函数，即在consts内声明的\n          stack.push(fn.apply(null, args))\n          continue\n        } else if(fn.value instanceof CustomFunc) { // 内置函数\n          fn.value.updateScope(args)\n          stack.push(fn.value.invokeBody())\n        }\n        break\n      }\n      case INSTR_FUNCDEF: { // 函数定义\n        if (typeof value !== 'string') {\n          stack.push(value); // 函数体\n          continue\n        }\n        if (stack.length === 0) return\n        const _scope = merge(Object.create(null), scope); // 作用域\n  \n        // done: 嵌套函数区分, 挂载到当前_scope上\n        _scope[value] = new Instruction<CustomFunc>(INSTR_EXECUTBODY, new CustomFunc(stack.pop(), values, _scope, ceval))\n  \n        Object.assign(scope, _scope)\n        break\n      }\n      default: {\n        const _val = Symbol('_init') // 值可能就是undefined，做区分\n        let val = _val\n        try {\n          val = item.value\n        } catch (e) {\n          // item = undefined | null | false | true ....\n        }\n        if (val !== _val) {\n          stack.push(val)\n        }\n      }\n    }\n  }\n  return statis ? stack : stack[0];\n}\n\nfunction specifyAttr<T>(value: string, [customValues, defaultValues], shouldCustom = false): T {\n  let fn: T\n  if(shouldCustom && hasAttribute(customValues, value)) {\n    fn = customValues[value] as T;\n  } else {\n    fn = defaultValues[value] as T;\n  }\n  return fn\n};\n\n// class Data {\n//   constructor()\n// }\n\nclass CustomFunc {\n  args: string[];\n\n  constructor(public func: Instruction<any>[], public values: Record<string, any>, public _scope: Record<string, any>, public ceval: Ceval) {\n    const args = this.func.splice(0, func.length - 1)\n    this.args = calculation(args, mapToObject(args, (k) => k), ceval, true)\n    this._scope = merge(mapToObject(args), _scope);\n  }\n\n  updateScope = (scope: any[]) => {\n    // 假设 Object attribute 是不保证顺序的。\n    this.args.forEach((key, index) => {\n      if(hasAttribute(this._scope, key)) {\n        this._scope[key] = scope[index]\n      }\n    });\n  }\n\n  invokeBody = () => {\n    return calculation(this.func, this.values, this.ceval, false, this._scope)\n  }\n}\n","import { getTime } from './index';\n\nconst [date, time] = getTime()\n\nexport default {\n  now: Date.now(),\n  date,\n  time,\n}","import Parser from './parser';\nimport Ceval from './index';\nimport Token from './token';\nimport TokenStream from './token-stream';\nimport Instruction from './instruction';\n\nexport type TypeParser = InstanceType<typeof Parser>\n\nexport type TypeCeval = InstanceType<typeof Ceval>\n\nexport type TypeToken = InstanceType<typeof Token>\n\nexport type TypeTokenStream = InstanceType<typeof TokenStream>\n\nexport type TypeInstruction = Instruction<any>\n\nexport type KeyOfValType<T extends object> = T[keyof T];\n\nexport class CevalOptions {\n  /**\n   * @desc 允许使用运算符\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  endableOperators?: boolean = true;\n\n  /**\n   * @desc 允许启用多位进制Number\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  endableBitNumber?: boolean = true;\n\n  /**\n   * @desc 允许访问成员\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  allowMemberAccess?: boolean = true;\n\n  /**\n   * @desc 允许默认放大计算，以处理四则运算的结果 e.g 0.1+0.2 !== 0.3  || 1.0-0.9 !== 0.1\n   * 在超出边界的情况下（ta > Number.MAX_SAFE_INTEGER || ta < Number.MIN_SAFE_INTEGER）会不做处理，还原四则运算\n   * @requires false \n   * @type {boolean}\n   */\n  allowHandleNumberPrecision?: boolean = true;\n\n  /**\n   * @desc 默认不允许操作符被 presetValue 覆盖\n   * @see 某些情况下开发者想制定更加精确的计算,例如BigInt,那么就在根据operatorMap声明presetValue={'+':Function}\n   * @requires false\n   * @type {boolean}\n   * @memberof CevalOptions\n   */\n  allowOperatorsCovered?: boolean = false;\n  \n  /**\n   * @desc 当没有返回值或为undefined时触发默认返回值\n   * @requires false\n   * @todo done\n   * @type {any}\n   */\n  defaultReturnValues?: any = '' // done\n}","import Parser from './parser';\nimport systemMap, { TypeUnary, TypeBinary, TypeTernary, TypeConst, TypeFunction, operatorMap } from './systemMap';\nimport TokenStream from './token-stream';\nimport calculation from './calculation';\nimport presetVariable from './utils/presetVariable';\nimport { merge } from './utils/index';\nimport { CevalOptions, TypeInstruction } from './interface';\n\nexport default class Ceval {\n  unaryOps: TypeUnary;\n\n  binaryOps: TypeBinary;\n\n  ternaryOps: TypeTernary;\n\n  consts: TypeConst;\n\n  functions: TypeFunction;\n\n  /**\n   * 操作符映射表，可做在presetValues覆盖运算\n   */\n  operatorMap = operatorMap;\n\n  private currentValues: Record<string, any> = { ...presetVariable};\n\n  constructor(private options: Readonly<CevalOptions> = {}) {\n    Object.assign(this, systemMap);\n    merge(this.options, new CevalOptions())\n  }\n\n  /**\n   * 查询支持的操作符方法名称, 可做覆盖\n   * @param ops 操作符\n   * @memberof Ceval\n   */\n  getSupportOperationMap = (ops: string): null | Function => {\n    return Object.prototype.hasOwnProperty.call(operatorMap, ops) ? operatorMap[ops] : null\n  }\n\n  /**\n   * 解析字符串，对外暴露方法\n   * @memberof Ceval\n   */\n  parseString = (expression: string, values: Record<string, any> = {}) => {\n    const instr: TypeInstruction[] = [];\n    const isDev = process.env.NODE_ENV !== 'development';\n    let value\n    if(isDev) {\n        Parser.generatorParser(this, new TokenStream(this, expression), instr)\n        value = this.injectValueToCalc(instr, values)\n    } else {\n      try {\n        Parser.generatorParser(this, new TokenStream(this, expression), instr)\n        value = this.injectValueToCalc(instr, values)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    return value\n  }\n\n  /**\n   * 获取当前数据池 预置+外置+内声明\n   * @returns 数据池\n   * @memberof Ceval\n   */\n  getCurrentValues = (): Record<string, any> => ({ ... this.currentValues});\n\n  /**\n   * 传入指令集开始计算\n   * @param {tokens} Instruction[] 指令集\n   * @param {Record<string, any>} [values={}] 数据池\n   * @memberof Ceval\n   */\n  private injectValueToCalc = (tokens: TypeInstruction[], values: Record<string, any> = {}): any => {\n    // @TODO 检查敏感字\n    // @TODO 检查关键字\n    this.updatePresetValues(values);\n    const result = calculation(tokens, this.currentValues, this)\n    return result === undefined ? this.options.defaultReturnValues : result\n  }\n\n  /**\n   * Update PresetValues\n   * @param {values} Record<string, any> 配置\n   * @memberof Ceval\n   */\n  updatePresetValues = (values: Record<string, any>): void => {\n    Object.assign(this.currentValues, values)\n  }\n\n  /**\n   * Update Option\n   * @param {Options} CevalOptions 配置\n   * @memberof Ceval\n   */\n  updateOptions = (Options: Partial<CevalOptions>): void => {\n    Object.assign(this.options, Options)\n  }\n\n  /**\n   * get Options\n   * @memberof Ceval\n   */\n  getOptions = () => {\n    return {...this.options};\n  }\n\n} "],"names":["Instruction","[object Object]","type","value","this","TOKEN_END","TOKEN_COMMA","TOKEN_NAME","TOKEN_SEMICOLON","Token","index","toString","bind","Object","prototype","isObject","obj","call","contains","source","hasOwnProperty","Array","isArray","some","v","indexOf","merge","target","keys","forEach","key","val","filterUndefine","args","one","item","undefined","hasAttribute","name","mapToObject","arr","defaultValue","length","element","push","unique","Error","join","create","someCondition","errMsg","pop","find","d","getReference","keyQueue","scope","values","path","shift","lastKey","TypeError","Reference","destoryed","getDigitLength","num","split","checkBounds","number","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getBaseNum","a","b","baseNum","Math","pow","max","unwantedHandlePercision","isInteger","system","functions","random","min","apply","f","map","x","i","consts","E","PI","true","false","null","NaN","Infinity","binaryOps","+","options","allowHandleNumberPrecision","round","-","*","/","%","^","||","n1","n2","&&","==","!=","!==",">","<",">=","<=","=","variables","[","array","===","in","String","eliminateQuote","str","quoteReg","test","result","exec","ternaryOps","?","cond","yep","nope","unaryOps","!","~","++","--","typeof","_typeof","match","toLowerCase","return","sin","cos","tan","syntaxOperator",":",".","excludeOperator","operatorMap","mapVal","data","object","cb","maps","includes","BLACK_LIST_OPERATORS","supportOperator","from","Set","concat","filter","op","sort","whitespaceReg","booleanReg","commentReg","stringReg","stringGreedyReg","number2bitReg","number8bitReg","number010bitReg","number10bitReg","number16bitReg","numberEbitReg","variableReg","operatorReg","RegExp","r","unaryMapReg","unarySymbolMapReg","constsMapReg","k","execFactoryReg","reg","expr","lastIndex","isUnaryOpeator","Parser","ceval","tokens","exprInstr","len","expression","parseExpression","current","nextToken","next","matchToken","accept","line","column","getCoordinates","printLog","console","error","savedCurrent","savedNextToken","temporarySaved","restore","instr","parseMultipleEvaluation","exp","parseAssignmentExpression","parseConditionalExpression","ident","parseOrExpression","trueBranch","falseBranch","expect","parseAndExpression","branch","parseBitwiseOrExpression","parseBitwiseAndExpression","parseEqualExpression","parseCompareExpression","parseInOrAtExpression","parseBitwiseMoveExpression","parseAddOrSubExpression","parseMulOrDivExpression","parseUnaryExpression","parseField","parseOuterFunctionCallExpression","parseMemberAccessExpression","parseArguments","count","refPath","currentItem","getOptions","allowMemberAccess","parseArrayLiteralDeclaration","parseObjectLiteralDeclaration","identifier","parseFunctionDefinedDeclaration","expreInstr","funcName","parseFunctionBodyExpression","SyntaxError","msg","tip","c","log","inspectParseEnd","parser","jsWord","abstract","arguments","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","eval","export","extends","final","finally","float","for","function","goto","if","implements","import","instanceof","int","interface","let","long","native","new","package","private","protected","public","short","static","super","switch","synchronized","throw","throws","transient","try","var","void","volatile","while","with","yield","jsAttr","Date","isFinite","isNaN","isPrototypeOf","valueOf","TokenStream","offset","start","pos","substr","newToken","isWhiteSpace","isComment","isNumber","isString","isBoolean","isParenthesis","isComma","isOperator","isSemicolon","isConst","isVariable","isFunctionDefined","isName","parseError","charAt","savedPosition","matchWS","getSomeCode","prefixCm","matchResult","word","getFirstWord","checkNextAccessGrammar","first","bit","n","endableBitNumber","base","times","parseFloat","parseInt","replace","matchString","strContent","surplusStr","substring","isPalindrome","constKey","endableOperators","ErrorType","coords","calculation","statis","stack","n3","fn","splice","specifyAttr","allowOperatorsCovered","setValue","destory","nextItem","ref","getValue","warn","CustomFunc","updateScope","invokeBody","_scope","assign","_val","Symbol","e","customValues","defaultValues","shouldCustom","func","date","time","o","now","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","t","getTime","CevalOptions","presetVariable","ops","process","env","NODE_ENV","generatorParser","injectValueToCalc","currentValues","updatePresetValues","defaultReturnValues","Options","systemMap"],"mappings":"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"}