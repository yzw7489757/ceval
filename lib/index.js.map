{"version":3,"file":"index.js","sources":["../src/instruction.ts","../src/token.ts","../src/utils/index.ts","../src/utils/functions.ts","../src/systemMap.ts","../src/utils/regExp.ts","../src/parser.ts","../src/utils/reservedWord.ts","../src/token-stream.ts","../src/calculation.ts","../src/utils/presetVariable.ts","../src/interface.ts","../src/index.ts"],"sourcesContent":["/** @desc 一元运算符 */\nexport const INSTR_OPERA1 = 'INSTR_OP1';\n/** @desc 二元运算符 */\nexport const INSTR_OPERA2 = 'INSTR_OP2';\n/** @desc 三元运算符 */\nexport const INSTR_OPERA3 = 'INSTR_OP3';\n\n/** @desc 数字 */\nexport const INSTR_NUMBER = 'INSTR_NUMBER';\n/** @desc 数组字面量 */\nexport const INSTR_ARRAY = 'INSTR_ARRAY';\n/** @desc 对象字面量 */\nexport const INSTR_OBJECT = 'INSTR_OBJECT';\n/** @desc 简单类型，表示不用处理 */\nexport const INSTR_PLAIN = 'INSTR_PLAIN';\n\n/** @desc 对象成员访问 */\nexport const INSTR_MEMBER = 'INSTR_MEMBER';\n\n/** @desc 表达式, 内置表达式 */\nexport const INSTR_EXPRE = 'INSTR_EXPRE';\n\n/** @desc 变量类型 const let var */\nexport const INSTR_VAR = 'INSTR_VAR';\n/** @desc 变量名称, 区别是内声明 TODO: var obj = {} */\nexport const INSTR_VARNAME = 'INSTR_VARNAME';\n/** @desc 变量名称, 取值, 没有经过声明的名称，例如 undefined, null, 以及数据池中的数据 */\nexport const INSTR_NAME = 'INSTR_NAME';\n\n/** @desc 函数调用 */\nexport const INSTR_FUNCALL = 'INSTR_FUNCALL'; // TODO: 函数声明\n/** @desc 函数定义指令 */\nexport const INSTR_FUNCDEF = 'INSTR_FUNCDEF';\n/** @desc 函数执行体 */\nexport const INSTR_EXECUTBODY = 'INSTR_EXECUTBODY';\n\n\n/**\n * @desc 指令实例\n */\nexport default class Instruction<T extends any> {\n\n  value: T;\n\n  constructor(public type: string, value?: any) {\n    this.value = (value !== undefined && value !== null) ? value : 0;\n  }\n}\n\n","/** @desc 结束标记 */\nexport const TOKEN_END = 'TOKEN_END';\n/** @desc 操作符类型 */\nexport const TOKEN_OPERATOR = 'TOKEN_OP';\n/** @desc 数字类型 */\nexport const TOKEN_NUMBER = 'TOKEN_NUMBER';\n/** @desc 字符串类型 */\nexport const TOKEN_STRING = 'TOKEN_STRING';\n/** @desc 圆括号，调用 */\nexport const TOKEN_PAREN = 'TOKEN_PAREN';\n/** @desc 方括号，成员访问 [] */\nexport const TOKEN_SQUARE = 'TOKEN_SQUARE';\n/** @desc 花括号，字面量声明 */\nexport const TOKEN_CURLY = 'TOKEN_CURLY';\n/** @desc 逗号 , */\nexport const TOKEN_COMMA = 'TOKEN_COMMA';\n/** @desc 变量 , */\nexport const TOKEN_VAR = 'TOKEN_VAR';\n/** @desc 变量名称 */\nexport const TOKEN_NAME = 'TOKEN_NAME';\n/** @desc 函数定义 */\nexport const TOKEN_FUNC = 'TOKEN_FUNC';\n/** @desc 结束标记; */\nexport const TOKEN_SEMICOLON = 'TOKEN_SEMICOLON';\n\n/**\n * tokenStream 解析阶段指令\n * @export \n * @class Token\n */\nexport default class Token {\n  constructor(public type: string, public value: any, public index: number) {\n    if ((window as any)._debug) {\n      console.log(`type: ${type}; value: ${value}; index: ${index}`)\n    }\n  }\n\n  toString = () => {\n    return this.type + ': ' + this.value;\n  };\n}\n\n","import Instruction from '../instruction';\n\nconst { toString } = Object.prototype;\n\n\nexport function isObject(obj): obj is object {\n  return toString.call(obj) === '[object Object]'\n}\n\n/**\n * @export\n * @template T\n * @param {array|object|string} source \n * @param {string} value\n * @returns {boolean}\n */\nexport function contains(source: any[] | Record<any, any> | string, value: string): boolean {\n  if (isObject(source)) {\n    return Object.prototype.hasOwnProperty.call(source, value)\n  } else if (Array.isArray(source)) {\n    return source.some(v => v === value)\n  }\n  return source.indexOf(value) > -1\n}\n\n/**\n * 获取日期时间\n * @export getTime\n * @param {number} [offset=0] 偏移量\n * @returns {string[]} [date, time]\n */\nexport function getTime(offset = 0): string[] {\n  const o = new Date(Date.now() + offset);\n  const date = `${o.getFullYear()}-${o.getMonth() + 1}-${o.getDate()}`\n  const clock = `${o.getHours()}:${o.getMinutes()}:${o.getSeconds()}`.replace(/\\d+/g, (t) => {\n    return parseInt(t, 10) < 10 ? `0${t}` : t\n  })\n\n  return [date, clock]\n}\n\n\n/**\n * 递归foreach\n * @export mapVal\n * @template T\n * @param {T} data\n * @param {Record<string, Record<string, any>>} object\n * @param {(data: T, key:string, val: any) => void} cb\n * @returns\n */\nexport function mapVal<T extends object>(data: T, object: object, cb: (data: T, key: string, val: any) => void) {\n  Object.keys(object).map(key => {\n    return isObject(object[key]) ? mapVal(data, object[key], cb) : cb(data, key, object[key])\n  })\n  return data\n}\n\n/**\n * 前者为主，仅合并不存在属性\n * @template T object\n * @param {T} target\n * @param {T} source\n */\nexport function merge<T>(target: T, source: T) {\n  Object.keys(source).forEach(key => {\n    const val = source[key]\n    if (Object.prototype.hasOwnProperty.call(target, key)) return\n    if (Array.isArray(val)) {\n      merge(target[key] = [], val)\n    } else if (isObject(val)) {\n      merge(target[key] = {}, val)\n    } else {\n      target[key] = val\n    }\n  })\n  return target\n}\n\n/**\n * 替换\\'\\' \\\"\\\" 在 处理 in operator 需要到\n * @param {string} str string Field\n * @returns {string} 没有对称引号的字符串\n */\nexport function eliminateQuote(str: string): string {\n  const quoteReg = /^\\\"(.*)\\\"$|^\\'(.*)\\'$/;\n  if (!quoteReg.test(str)) return str\n  const result = quoteReg.exec(str)\n  const s = result[1] !== undefined ? result[1] : result[2]\n  return eliminateQuote(s)\n}\n/**\n * 回文字符串 \\'\\'a\\'\\' ✅  \\'\\'a\\'❌\n * @param {string} str\n * @returns\n */\nexport function isPalindrome(str: string) {\n  let i = 0\n  while (contains(['\\'', '\\\"'], str.charAt(i)) && str.charAt(i) === str.charAt(str.length - 1 - i)) {\n    i++\n  }\n  const surplusStr = str.substring(i, str.length - i)\n  return surplusStr.indexOf('\\\"') === -1 && surplusStr.indexOf('\\'') === -1\n}\n\n/**\n * 返回首个有效数据， 非undefined null false true\n * @param {*} args\n */\nexport function filterUndefine(...args) {\n  let one\n  args.some(item => {\n    if (contains([undefined, null, true, false], item)) return false\n    one = item\n    return true;\n  })\n  return one\n}\n\n\nexport function hasAttribute(obj: object, name: string) {\n  return Object.prototype.hasOwnProperty.call(obj, name)\n}\n\n/**\n * Array to Object e.g. ['a', 'b'] => { a: undefined, b: undefined }\n * @param {string[]} arr \n */\nexport function mapToObject(arr: string[] | Instruction<any>[], defaultValue: undefined | ((key: string) => any) = undefined) {\n  if (typeof arr[0] === 'string' && arr.length !== [...new Set(arr as any)].length) {\n    // 参数重复\n    throw new Error(`Duplicate parameter: ${arr.join(',')}`)\n  }\n  const obj = Object.create(null)\n  arr.forEach((item) => {\n    let key\n    if (item instanceof Instruction) {\n      key = item.value\n    } else {\n      key = item\n    }\n    obj[key] = (typeof defaultValue === 'function' ? defaultValue(key) : defaultValue)\n  })\n  return obj\n}\n\nexport function someCondition(...args) {\n  const errMsg = args.pop();\n\n  if (!args.find(d => !!d)) {\n    throw new Error(errMsg)\n  }\n}\n/**\n * \n * @param keyQueue [\"obj\", \"arr\"] key path\n * @param scope 当前作用域\n * @param values 顶层作用域\n */\nexport function getReference(keyQueue: string[], scope: Record<string, any>, values: Record<string, any>): Reference {\n  if (keyQueue.length < 2) return hasAttribute(scope, keyQueue[0]) ? scope[keyQueue[0]] : values[keyQueue[0]];\n  let path = keyQueue.shift();\n  const lastKey = keyQueue.pop();\n  let target = hasAttribute(scope, path) ? scope : values;\n  while (path) {\n    if (hasAttribute(target, path)) {\n      target = target[path];\n    } else if (!target) {\n      throw new TypeError(`Uncaught TypeError: Cannot read property '${path}' of ${target}`)\n    } else {\n      target = undefined\n    }\n    path = keyQueue.shift()\n  }\n  console.log('target: ', target, lastKey);\n  return new Reference(target, lastKey)\n}\n\nexport class Reference {\n  destoryed: boolean;\n\n  constructor(public target: any, public path: string) {\n    this.destoryed = false\n  }\n\n  setValue(value) {\n    if(this.destoryed) return value\n    return (this.target[this.path] = value)\n  }\n\n  getValue() {\n    if(this.destoryed) return undefined\n    return this.target[this.path]\n  }\n\n  destory() {\n    // 使用一次就释放掉内存\n    this.destoryed = true\n    this.target = null;\n  }\n}","import { contains, isObject, eliminateQuote } from './index';\nimport { CevalOptions } from '../interface';\n\nfunction getDigitLength(num: number){\n  return (num.toString().split('.')[1] || '').length;\n}\n\nfunction checkBounds(number: number) {\n  return number > Number.MAX_SAFE_INTEGER || number < Number.MIN_SAFE_INTEGER\n}\n\nfunction getBaseNum(a: number, b: number): number {\n  const baseNum = Math.pow(10, Math.max(getDigitLength(a), getDigitLength(b)));\n  if(checkBounds(a * baseNum) || checkBounds(b * baseNum)) { // 超出边界的情况不予处理\n    return 0\n  }\n  return baseNum\n}\n\nconst unwantedHandlePercision = (a, b) => {\n  // 整数不需要处理 || 非Number也不需要\n  return (Number.isInteger(a) && Number.isInteger(b)) || (typeof a !== 'number' || typeof b !== 'number')\n}\n\nexport function add(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a + b\n  const baseNum = getBaseNum(a,b);\n  return baseNum === 0 ? a + b : (Math.round(a * baseNum) + Math.round(b * baseNum)) / baseNum \n}\n\nexport function sub(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a - b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a - b : (Math.round(a * baseNum) - Math.round(b * baseNum)) / baseNum;\n}\n\nexport function mul(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a * b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a * b : (Math.round(a * baseNum) * Math.round(b * baseNum)) / Math.pow(baseNum, 2);\n}\n\nexport function divide(a: number, b: number, options: CevalOptions): number {\n  if( options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a / b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a / b : (Math.round(a * baseNum) / Math.round(b * baseNum));\n}\n\nexport function mod(a, b) {\n  return a % b;\n}\n\nexport function equal(a, b) {\n  // eslint-disable-next-line\n  return a == b;\n}\n\nexport function strictEqual(a, b) {\n  return a === b;\n}\n\nexport function notEqual(a, b) {\n  // eslint-disable-next-line\n  return a != b;\n}\n\nexport function strictNotEqual(a, b) {\n  return a !== b;\n}\n\nexport function greaterThan(a, b) {\n  return a > b;\n}\n\nexport function lessThan(a, b) {\n  return a < b;\n}\n\nexport function greaterThanEqual(a, b) {\n  return a >= b;\n}\n\nexport function _typeof(a){\n  return Object.prototype.toString.call(a).match(/^\\[object\\s*(\\w+?)\\]$/)[1].toLowerCase()\n}\n\nexport function lessThanEqual(a, b) {\n  return a <= b;\n}\n\nexport function inTheTarget(a, b) {\n  if(typeof b !== 'object' || String(a) !== `${a}` ) throw new Error('first argument must be original type, second must be Array or Object')\n  return isObject(b) ? Object.prototype.hasOwnProperty.call(b, eliminateQuote(a)) : contains(b, a)\n}\n\nexport function bitWiseOr(a, b) {\n  return a ^ b\n}\n\nexport function setVar(name: string | number, value: any, variables: object | Array<any> ) {\n  if (variables) variables[name] = value;\n  return value;\n}\n\nexport function arrayIndex(array, index) {\n  return array[index | 0];\n}\n\nexport function condition(cond, yep, nope) {\n  return cond ? yep : nope;\n}\n\nexport function withOr(n1, n2) {\n  return n1 ? n1 : n2\n}\n\nexport function withAlso(n1, n2) {\n  return n1 ? n2 : n1\n}\n\nexport function max(...args: number[]) {\n  if (args.length === 1) {\n    return Math.max.apply(Math, args);\n  } else {\n    return Math.max.apply(Math, args);\n  }\n}\n\nexport function min(...args: number[]) {\n  if (args.length === 1) {\n    return Math.min.apply(Math, args);\n  } else {\n    return Math.min.apply(Math, args);\n  }\n}\n\nexport function arrayMap(f: (val: any, index?: number) => any, a: any[]) {\n  if (typeof f !== 'function') {\n    throw new Error('First argument is not a function');\n  }\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument is not an array');\n  }\n  return a.map(function (x, i) {\n    return f(x, i);\n  });\n}\n\nexport function random(a) {\n  return Math.random() * (a || 1);\n}\n\nfunction decimalAdd(num1, num2) {\n  const num1Digits = (num1.toString().split('.')[1] || '').length;\n  const num2Digits = (num2.toString().split('.')[1] || '').length;\n  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}","import { mapVal } from './utils/index';\nimport {\n  // 功能性\n  random, min, max, arrayMap as map, _typeof,\n  // 二元\n  add, sub, mul, divide, mod, withOr, withAlso, equal, notEqual, greaterThan, lessThan, greaterThanEqual, lessThanEqual, inTheTarget, setVar, arrayIndex, bitWiseOr, strictNotEqual,\n  // 三元\n  condition,\n  strictEqual\n} from './utils/functions';\n\nconst system = {\n  functions: {\n    random,\n    min,\n    max,\n    map,\n    pow: Math.pow,\n  },\n  consts: {\n    E: Math.E,\n    PI: Math.PI,\n    'true': true,\n    'false': false,\n    \"undefined\": undefined,\n    \"null\": null,\n    \"NaN\": Number.NaN,\n    \"Infinity\": Infinity\n  },\n  binaryOps: {\n    '+': add,\n    '-': sub,\n    '*': mul,\n    '/': divide,\n    '%': mod,\n    '^': bitWiseOr,\n    '||': withOr,\n    '&&': withAlso,\n    '==': equal,\n    '!=': notEqual,\n    '!==': strictNotEqual,\n    '>': greaterThan,\n    '<': lessThan,\n    '>=': greaterThanEqual,\n    '<=': lessThanEqual,\n    '=': setVar,\n    '[': arrayIndex,\n    '===': strictEqual,\n    'in': inTheTarget,\n    // 'instanceOf'\n  },\n  ternaryOps: {\n    '?': condition\n  },\n  unaryOps: {\n    '+': (v): number => +v,\n    '-': (v): number => -v,\n    '!': (v): boolean => !v,\n    '~': (v): number => ~v,\n    '++': (v): number => v += 1,\n    '--': (v): number => v -= 1,\n    'typeof': (v): string => _typeof(v),\n    'return': v => v,\n    sin: Math.sin,\n    cos: Math.cos,\n    tan: Math.tan,\n  },\n  syntaxOperator: {\n    ':': null,\n    '.': null,\n  }\n}\n\nexport default system;\n\n/** @desc 功能函数 */\nexport type TypeFunction = typeof system.functions;\n/** @desc 常量设置 */\nexport type TypeConst = typeof system.consts;\n/** @desc 一元运算符 */\nexport type TypeUnary = typeof system.unaryOps;\n/** @desc 二元运算符 */\nexport type TypeBinary = typeof system.binaryOps;\n/** @desc 三元运算符 */\nexport type TypeTernary = typeof system.ternaryOps;\n/** @desc 词法操作符 */\nexport type TypeSyntax = typeof system.syntaxOperator;\n\n// 有些运算符不能被修改。\n\nconst excludeOperator = ['=', '['];\n\n/** @desc 运算符映射表 */\nexport const operatorMap = mapVal(Object.create(null), {\n  functions: system.functions,\n  consts: system.consts,\n  unaryOps: system.unaryOps,\n  ternaryOps: system.ternaryOps,\n}, (maps, key, val) => {\n  if(!excludeOperator.includes(key)) {\n    maps[key] = val\n  }\n})","/** \n * @desc   : desc \n * @author : ziwen\n * @date   : 2020-6-2 10:55:30\n */\nimport system from '../systemMap';\nimport { contains } from './index';\n\nconst BLACK_LIST_OPERATORS = []\nconst supportOperator = Array.from(new Set(\n  [].concat(\n    Object.keys(system.unaryOps).filter(item => !/\\b\\w+\\b/.test(item)),\n    Object.keys(system.binaryOps),\n    Object.keys(system.ternaryOps),\n    Object.keys(system.syntaxOperator)\n  )\n    .filter(op => !contains(BLACK_LIST_OPERATORS, op))\n    .sort((a, b) => b.length - a.length)\n))\n\nexport const whitespaceReg = /(\\t|\\n|\\r|\\s+)/;\nexport const booleanReg = /^(false|true)/;\nexport const commentReg = /^\\/\\*(.*?)\\*\\//;\nexport const stringReg = /^\\'(.*?)\\'|^\\\"(.*?)\\\"/;\nexport const stringGreedyReg = /^\\'(.*)\\'|^\\\"(.*)\\\"/;\n// export const regExpReg = /^ExecReg\\((.*)\\)/;\n\nexport const number2bitReg = /^(0b[0|1]{1,})$/;\nexport const number8bitReg = /^(0[0-7]{1,})$/;\nexport const number010bitReg = /^(0\\d*[8-9]{1,}\\d*(\\.\\d+)?)$/; // 0开头的十进制 019 038 078\nexport const number10bitReg = /(^([1-9]\\d*(\\.\\d+)|(\\d*(\\.\\d+)?)))/; // 1-9 或者.开头的十进制\nexport const number16bitReg = /^(0x[0-9a-fA-F]{1,})$/;\nexport const numberEbitReg =  /^((\\d*\\.?\\d*)[e|E]((\\-|\\+)?\\d+))/; // 科学计数法\n\nexport const variableReg = /^((_|$)?[0-9a-zA-Z|$|_]{1,})/;\nexport const operatorReg = new RegExp(`^(${supportOperator.map(r => `(\\\\${/\\b\\w+\\b/.test(r) ? `${r}\\\\s+` : r.split('').join('\\\\')})`).join('|')})`);\nexport const unaryMapReg = new RegExp(`^(${Object.keys(system.unaryOps).filter(item => /\\b\\w+\\b/.test(item)).join('|')})`);\nexport const unarySymbolMapReg = new RegExp(`^(${Object.keys(system.unaryOps).filter(item => !(/\\b\\w+\\b/.test(item))).map(r => `\\\\s*\\\\${r}\\\\s*`).join('|')})`);\nexport const constsMapReg = new RegExp(`^(${Object.keys(system.consts).map(k=>`${k}`).join('|')})`)\n\nexport const execFactoryReg = (reg: RegExp, expr: string, cb: <T>(v: T) => T = (v => v)): string | undefined => {\n  reg.lastIndex = 0;\n  const result = reg.exec(expr);\n  if (result === null || result[0] === '') {\n    return cb(undefined)\n  } else {\n    return cb(result[1])\n  }\n}\n\nexport const isUnaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.unaryOps, value)\nexport const isBinaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.binaryOps, value)\nexport const isTernaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.ternaryOps, value)","import Ceval from './index';\nimport { TypeTokenStream, TypeToken, TypeInstruction } from './interface';\nimport Instruction, { INSTR_EXPRE, INSTR_FUNCDEF, INSTR_PLAIN, INSTR_VARNAME, INSTR_NAME, INSTR_FUNCALL, INSTR_OBJECT, INSTR_OPERA1, INSTR_MEMBER, INSTR_OPERA2, INSTR_OPERA3, INSTR_ARRAY, INSTR_NUMBER, INSTR_VAR } from './instruction';\nimport { TOKEN_OPERATOR, TOKEN_NAME, TOKEN_SQUARE, TOKEN_PAREN, TOKEN_NUMBER, TOKEN_STRING, TOKEN_COMMA, TOKEN_SEMICOLON, TOKEN_END, TOKEN_CURLY, TOKEN_VAR, TOKEN_FUNC } from './token';\nimport { unarySymbolMapReg, isUnaryOpeator } from './utils/regExp';\nimport { contains } from './utils/index';\n\n/**\n * 解析器\n * @export\n * @class Parser\n */\nexport default class Parser {\n  /**\n   * @desc 当前TOKEN指针\n   */\n  current: TypeToken | null = null;\n\n  /**\n   * @desc 暂存指针\n   */\n  savedCurrent: TypeToken | null = null;\n\n  /**\n   * @desc 下个TOKEN指针对象\n   */\n  nextToken: TypeToken | null = null;\n\n  /**\n   * @desc 暂存next TOKEN\n   */\n  savedNextToken: TypeToken | null = null;\n\n  constructor(public ceval: Ceval, public tokens: TypeTokenStream, exprInstr: TypeInstruction[]) {\n    this.next();\n    \n    this.inspectParseEnd(exprInstr)\n  }\n\n  /**\n   * 检查是否解析完毕\n   */\n  private inspectParseEnd = (exprInstr: TypeInstruction[]) => {\n    const len = this.tokens.expression.length\n    do {\n      this.parseExpression(exprInstr)\n    } while (this.current.index < len && this.nextToken.type !== TOKEN_END) \n  }\n\n  /**\n   * 生成实例解析表达式，简化调用方式\n   */\n  static generatorParser = (parser: Ceval, tokens: TypeTokenStream, exprInstr: TypeInstruction[]): Parser => {\n    return new Parser(parser, tokens, exprInstr)\n  }\n\n  /**\n   * Token指针向下位移\n   */\n  next = (): TypeToken => {\n    this.current = this.nextToken;\n    return (this.nextToken = this.tokens.next())\n  }\n\n  /**\n   * 条件是否命中Token真值\n   */\n  matchToken = (value: undefined | ((value: TypeToken) => boolean) | string | number): boolean => {\n    if (value === undefined) {\n      return true\n    } else if (Array.isArray(value)) {\n      return value.indexOf(this.nextToken.value) !== -1\n    } else if (typeof value === 'function') {\n      return value(this.nextToken)\n    } else if (typeof value === 'string' || typeof value === 'number') {\n      return value === this.nextToken.value\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * 预判是否符合预期，符合&&解析下个token\n   * @param {type} 约定的类型\n   * @param {value} 明确规定的字面值，比如 ] , =\n   * @param {next} 允许next？\n   */\n  accept = (type: string, value?, next = true): boolean => {\n    if (this.nextToken && (this.nextToken.type === type) && this.matchToken(value)) {\n      if (next) this.next()\n      return true\n    }\n    return false\n  }\n\n  /**\n   * accpet + 断言\n   * @param {type} 约定的类型\n   * @param {value} 明确规定的字面值，比如 ] , =\n   */\n  expect = (type: string, value?): never | boolean => {\n    if (!this.accept(type, value)) {\n      const { line, column } = this.tokens.getCoordinates()\n      this.printLog(`> line:${line} column:${column - 1} \"${this.current.value}\"\\nThe next tag should be \"${value}\", But the reality is`, `${this.nextToken.type === TOKEN_END ? 'empty content' : `\"${this.nextToken.value}\"`}`\n        , console.error\n      )\n      throw new Error('Unexpected Tag');\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * 暂存指针，在某些情况下单一的nextToken已经不满足预判情况，例如 typeof(add) || add(1, 2) || 1 + add;\n   */\n  temporarySaved = (): void => {\n    this.savedCurrent = this.current;\n    this.savedNextToken = this.nextToken;\n\n    this.tokens.temporarySaved()\n  }\n\n  /**\n   * 恢复指针\n   */\n  restore = (): void => {\n    this.current = this.savedCurrent;\n    this.nextToken = this.savedNextToken;\n    this.tokens.restore()\n    return void 0;\n  }\n\n  /**\n   * 解析表达式整个句柄\n   * @see 如果只是求参或解析字面量，请从Conditional开始，因为MultipleEvaluation可能会误会语义，e.g.{a:1,b:2}中的“1,b:2”\n   */\n  parseExpression = (instr: TypeInstruction[]): void => {\n    const exprInstr: TypeInstruction[] = []\n    \n    this.parseMultipleEvaluation(exprInstr)\n    exprInstr.forEach(exp => (instr.push(exp)))\n  }\n\n  /**\n   * 解析连续求值 例如 数组字面量 [1, 2, [3, 4, 5]]  (1, 2, 3)\n   */\n  parseMultipleEvaluation = (exprInstr: TypeInstruction[]): void => {\n    this.parseAssignmentExpression(exprInstr)\n    while (this.accept(TOKEN_COMMA, ',')) {\n      this.parseConditionalExpression(exprInstr)\n    }\n  }\n\n  /**\n   * 解析变量赋值表达式 TOKEN_OPERATOR name = 1\n   */\n  parseAssignmentExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseConditionalExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '=')) {\n      let ident: TypeInstruction\n      if(exprInstr[exprInstr.length - 1].type === INSTR_VAR){\n        ident = exprInstr.pop()\n      };\n      const instr: TypeInstruction[] = []\n      this.parseConditionalExpression(instr)\n      exprInstr.push(new Instruction(INSTR_EXPRE, instr));\n      if(ident) {\n        exprInstr.push(ident)\n      } else {\n        exprInstr.push(new Instruction(INSTR_OPERA2, '='))\n      }\n    }\n  }\n\n  /**\n   * 解析三目运算符\n   */\n  parseConditionalExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseOrExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '?')) {\n      const trueBranch = [];\n      const falseBranch = [];\n      this.parseConditionalExpression(trueBranch);\n      this.expect(TOKEN_OPERATOR, ':');\n      this.parseConditionalExpression(falseBranch);\n      exprInstr.push(new Instruction(INSTR_EXPRE, trueBranch));\n      exprInstr.push(new Instruction(INSTR_EXPRE, falseBranch));\n      exprInstr.push(new Instruction(INSTR_OPERA3, '?'));\n    }\n  }\n\n  /**\n   * 解析 ||\n   */\n  parseOrExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseAndExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '||')) {\n      var branch = []\n      this.parseAndExpression(branch)\n      exprInstr.push(new Instruction(INSTR_EXPRE, branch))\n      exprInstr.push(new Instruction(INSTR_OPERA2, '||'))\n    }\n  }\n\n  /**\n   * 解析 &&\n   */\n  parseAndExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseOrExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '&&')) {\n      var branch = []\n      this.parseBitwiseOrExpression(branch)\n      exprInstr.push(new Instruction(INSTR_EXPRE, branch))\n      exprInstr.push(new Instruction(INSTR_OPERA2, '&&'))\n    }\n  }\n\n  /**\n   * 解析 ^ 按位异或\n   */\n  parseBitwiseOrExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseAndExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '^')) {\n      this.parseBitwiseAndExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, '^'))\n    }\n  }\n\n  /**\n   * 解析 & 按位与\n   */\n  parseBitwiseAndExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseEqualExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '&')) {\n      this.parseBitwiseAndExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, '&'))\n    }\n  }\n\n  /**\n   * 解析判等 ['==', '===', '!=', '!==']\n   */\n  parseEqualExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseCompareExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['==', '===', '!=', '!=='])) {\n      var op = this.current\n      this.parseCompareExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析比较运算符 ['<', '<=', '>=', '>']\n   */\n  parseCompareExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseInOrAtExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['<', '<=', '>=', '>'])) {\n      var op = this.current\n      this.parseInOrAtExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n  * 解析或运算符 ['||', '@'] @待补位\n  */\n  parseInOrAtExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseMoveExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['in'/** ,\"@\" */])) {\n      var op = this.current\n      this.parseBitwiseMoveExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析按位移 [\">>\", \">>>\", \"<<\"]\n   */\n  parseBitwiseMoveExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseAddOrSubExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\">>\", \">>>\", \"<<\"])) {\n      var op = this.current\n      this.parseAddOrSubExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析加减法 + -\n   */\n  parseAddOrSubExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseMulOrDivExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\"+\", \"-\"])) {\n      var op = this.current\n      this.parseMulOrDivExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析乘除取模 * / %\n   */\n  parseMulOrDivExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseUnaryExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\"*\", \"/\", \"%\"])) {\n      var op = this.current\n      this.parseUnaryExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析一元运算符 [+, ++, +, -, !, ~, cos, tan, typeof]\n   */\n  parseUnaryExpression = (exprInstr: TypeInstruction[]): void => {\n    this.temporarySaved();\n    if (this.accept(TOKEN_OPERATOR, isUnaryOpeator)) {// 内置函数调用\n      if (unarySymbolMapReg.test(this.current.value)) { // +, ++, +, -, !, ~,\n        const op = this.current\n        this.parseUnaryExpression(exprInstr); // 兼容 ++-1\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      } else if (this.accept(TOKEN_PAREN, '(', false)) { // typeof(\n        const op = this.current\n        this.accept(TOKEN_PAREN, '(')\n        this.parseConditionalExpression(exprInstr);\n        this.expect(TOKEN_PAREN, ')')\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      } else if (\n        [TOKEN_COMMA, TOKEN_SEMICOLON, TOKEN_END].indexOf(this.nextToken.type) !== -1 || // typeof, typeof; typeof\n        (this.nextToken.type === TOKEN_PAREN && this.nextToken.value === ')') // typeof)\n      ) {\n        this.restore();\n        this.parseField(exprInstr);\n      } else { // 需要支持typeof 1 ; typeof typeof 1 === typeof(typeof(1)) === typeof(typeof 1);\n        const op = this.current\n        this.parseUnaryExpression(exprInstr) // 外置函数 || 内声明函数\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      }\n    } else {\n      this.parseOuterFunctionCallExpression(exprInstr) // 外置函数 || 内声明函数\n    }\n  }\n\n  /**\n   * 外置函数调用\n   */\n  parseOuterFunctionCallExpression = (exprInstr: TypeInstruction[]) => {\n    this.parseMemberAccessExpression(exprInstr)\n    if (this.current.type === TOKEN_NAME && this.accept(TOKEN_PAREN, '(', false)) {\n      this.parseArguments(exprInstr)\n    }\n  }\n\n  /**\n   * 解析内置函数调用\n   */\n  // parsePersetFuncCallExpression = (exprInstr: TypeInstruction[]): void => {\n  //     this.parseMemberAccessExpression(exprInstr); // a.b()\n  //     this.parseArguments(exprInstr)\n  // }\n\n  /**\n   * 解析调用函数的实参\n   */\n  parseArguments = (exprInstr: TypeInstruction[]): void => {\n    while (this.accept(TOKEN_PAREN, '(')) {\n      if (this.accept(TOKEN_PAREN, ')')) {\n        // 立即调用\n        exprInstr.push(new Instruction(INSTR_FUNCALL, 0)) // 参数长度 \n      } else {\n        let count = 0\n        while (!this.accept(TOKEN_PAREN, ')')) {\n          do {\n            this.parseConditionalExpression(exprInstr);\n            count++;\n          } while (this.accept(TOKEN_COMMA))\n        }\n        exprInstr.push(new Instruction(INSTR_FUNCALL, count))\n      }\n    }\n  }\n\n  /**\n   * 解析成员访问符 . []\n   */\n  parseMemberAccessExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseField(exprInstr);\n    const refPath = [];\n    const currentItem = exprInstr[exprInstr.length - 1];\n    if(currentItem && currentItem.type === INSTR_NAME) {\n      refPath.push(currentItem.value) // 尝试最后一个是否是NAME变量\n    }\n    while (\n      this.accept(TOKEN_OPERATOR, '.') ||\n      (contains([TOKEN_SQUARE, TOKEN_NAME], this.current.type) && this.accept(TOKEN_SQUARE, '['))) {\n        \n      if (!this.ceval.getOptions().allowMemberAccess) {\n        throw new Error(`options \"allowMemberAccess\": You have disabled member access and cannot use syntax such as \"a.b\" \"a['b']\"`)\n      }\n      if (this.current.value === '.') {\n        this.expect(TOKEN_NAME); // a.name ✔️  a.1×\n        refPath.push(this.current.value)\n      } else if (this.current.value === '[' && (this.accept(TOKEN_NAME) || this.accept(TOKEN_NUMBER) || this.accept(TOKEN_STRING))) {\n        refPath.push(this.current.value)\n        this.expect(TOKEN_SQUARE, ']')\n      }\n    }\n    if(refPath.length > 1) {\n      exprInstr.pop(); // 拿到全部引用\n      exprInstr.push(new Instruction(INSTR_MEMBER, refPath))\n    }\n  }\n\n\n  /**\n   * 解析字面值、字段值 number||string||operator(typeof cos tan)||[1,2,3]|| {a:1,b:{}} || (expression) || function abs() {}\n   */\n  parseField = (exprInstr: TypeInstruction[]): void => {\n    if (this.accept(TOKEN_OPERATOR, isUnaryOpeator)) {\n      // 内置前缀运算符 cos tan - +\n      exprInstr.push(new Instruction(INSTR_OPERA1, this.current.value));\n    } else if (this.accept(TOKEN_NAME)) {\n      // 变量名称\n      if(this.accept(TOKEN_OPERATOR, '=', false)) {// 赋值操作，避免转成TOKEN_NAME去取值了。\n        exprInstr.push(new Instruction(INSTR_VARNAME, this.current.value));\n      } else {\n        exprInstr.push(new Instruction(INSTR_NAME, this.current.value));\n      }\n    } else if (this.accept(TOKEN_NUMBER)) {\n      // 数字类型\n      exprInstr.push(new Instruction(INSTR_NUMBER, this.current.value));\n    } else if (this.accept(TOKEN_STRING)) {\n      // 字符串类型 \\\"name\\\"\n      exprInstr.push(new Instruction(INSTR_PLAIN, this.current.value));\n    } else if (this.accept(TOKEN_PAREN, '(')) {\n      // 圆括号，调用 或 表达式(a=1)\n      this.parseExpression(exprInstr);\n      this.expect(TOKEN_PAREN, ')');\n    } else if (this.accept(TOKEN_SQUARE, '[')) {\n      //  数组字面量\n      this.parseArrayLiteralDeclaration(exprInstr)\n    } else if (this.accept(TOKEN_CURLY, '{', false)) {\n      // Object字面量声明\n      this.parseObjectLiteralDeclaration(exprInstr)\n    } else if (this.accept(TOKEN_VAR, ['const', 'var', 'let'])) {\n      // 赋值表达式 需要收集ident 和 variableName 避免variableName识别成varName 引发error\n      const identifier = this.current\n      this.expect(TOKEN_NAME)\n      exprInstr.push(new Instruction(INSTR_VARNAME, this.current.value));\n      exprInstr.push(new Instruction(INSTR_VAR, identifier.value))\n    } else if (this.accept(TOKEN_FUNC, undefined, false)) {\n      this.parseFunctionDefinedDeclaration(exprInstr);\n    } else if (this.accept(TOKEN_SEMICOLON)) {\n      // empty, fault tolerant \n    } else {\n      throw new Error('unexpected ' + this.nextToken);\n    }\n  }\n\n  /**\n   * 解析对象字面量 { a: 1, b: 2, c: {}}\n   */\n  parseArrayLiteralDeclaration = (exprInstr: TypeInstruction[]) => {\n    // Array字面量声明 TODO: 需要和 obj['a'] 做区分\n    const instr = []\n    if (this.accept(TOKEN_SQUARE, ']')) { // []\n      exprInstr.push(new Instruction(INSTR_ARRAY, instr))\n      return\n    }\n    this.parseExpression(instr)\n    this.expect(TOKEN_SQUARE, ']')\n    exprInstr.push(new Instruction(INSTR_ARRAY, instr))\n  }\n\n  /**\n   * 解析对象字面量 { a: 1, b: 2, c: {}}\n   */\n  parseObjectLiteralDeclaration = (exprInstr: TypeInstruction[]) => {\n    while (this.accept(TOKEN_CURLY, '{')) {\n      const instr = {}\n      if (this.accept(TOKEN_CURLY, '}')) { // {}\n        exprInstr.push(new Instruction(INSTR_OBJECT, instr))\n        return\n      }\n      while (this.accept(TOKEN_NAME) || this.accept(TOKEN_NUMBER) || this.accept(TOKEN_STRING)) {\n        const key = this.current.value\n        this.expect(TOKEN_OPERATOR, ':');\n        instr[key] = [];\n        if (this.accept(TOKEN_CURLY, '{', false)) {\n          this.parseObjectLiteralDeclaration(instr[key])\n        } else {\n          this.parseConditionalExpression(instr[key]);\n        }\n        this.accept(TOKEN_COMMA, ',');\n      }\n      this.expect(TOKEN_CURLY, '}');\n      this.accept(TOKEN_SEMICOLON, ';')\n      exprInstr.push(new Instruction(INSTR_OBJECT, instr))\n    }\n  }\n\n  /**\n   * 解析函数声明\n   */\n  parseFunctionDefinedDeclaration = (expreInstr: TypeInstruction[]) => {\n    while (this.accept(TOKEN_FUNC)) {\n      if (this.accept(TOKEN_NAME)) { // function fn(){}\n        const funcName = this.current.value;\n        const instr = []; // 参数 与 函数体\n        if (this.accept(TOKEN_PAREN, '(')) {\n          do {\n            this.parseField(instr); // TODO fn(a=1) 待兼容\n          } while (this.accept(TOKEN_COMMA))\n          this.expect(TOKEN_PAREN, ')')\n        }\n        this.parseFunctionBodyExpression(instr)\n        expreInstr.push(new Instruction(INSTR_FUNCDEF, instr))\n        expreInstr.push(new Instruction(INSTR_FUNCDEF, funcName))\n      }\n    }\n  }\n\n  /**\n   * 解析函数体, 花括号 { }, 应该视作一个新的作用域. // TODO: 可作为单独作用域体\n   */\n  parseFunctionBodyExpression = (exprInstr: TypeInstruction[]) => {\n    if (this.accept(TOKEN_CURLY, '{')) {\n      const instr = [];\n      do {\n        this.parseExpression(instr)\n      } while (this.accept(TOKEN_SEMICOLON, ';') && !this.accept(TOKEN_CURLY, '}', false))\n      if(this.current.type !== TOKEN_SEMICOLON) {\n        throw new SyntaxError(`Function parse error: Function body each line must end with semicolon ';'`)\n      }\n      this.expect(TOKEN_CURLY, '}')\n      this.accept(TOKEN_SEMICOLON, ';')\n      exprInstr.push(new Instruction(INSTR_EXPRE, instr))\n    }\n  }\n\n  /**\n   * 增加提示\n   */\n  printLog = (msg: string, tip: string, c: Console[\"log\" | \"error\" | \"warn\"] = console.log) => {\n    c(`${msg} %c${tip}`, `margin: 0 .5em;text-decoration-line: underline;text-decoration-color: red;text-decoration-style: wavy;line-height: 2em;color: red;`)\n  }\n}","/** @desc javascript保留字 */\nexport const jsWord = {\n  \"abstract\": false,\n  \"arguments\": false,\n  \"boolean\": false,\n  \"break\": false,\n  \"byte\": false,\n  \"case\": false,\n  \"catch\": false,\n  \"char\": false,\n  \"class\": false,\n  \"const\": false,\n  \"continue\": false,\n  \"debugger\": false,\n  \"default\": false,\n  \"delete\": false,\n  \"do\": false,\n  \"double\": false,\n  \"else\": false,\n  \"enum\": false,\n  \"eval\": false,\n  \"export\": false,\n  \"extends\": false,\n  \"final\": false,\n  \"finally\": false,\n  \"float\": false,\n  \"for\": false,\n  \"function\": false,\n  \"goto\": false,\n  \"if\": false,\n  \"implements\": false,\n  \"import\": false,\n  \"in\": true,\n  \"instanceof\": false,\n  \"int\": false,\n  \"interface\": false,\n  \"let\": false,\n  \"long\": false,\n  \"native\": false,\n  \"new\": false,\n  \"null\": false,\n  \"package\": false,\n  \"private\": false,\n  \"protected\": false,\n  \"public\": false,\n  \"return\": true,\n  \"short\": false,\n  \"static\": false,\n  \"super\": false,\n  \"switch\": false,\n  \"synchronized\": false,\n  \"this\": false,\n  \"throw\": false,\n  \"throws\": false,\n  \"transient\": false,\n  \"try\": false,\n  \"typeof\": false,\n  \"var\": false,\n  \"void\": false,\n  \"volatile\": false,\n  \"while\": false,\n  \"with\": false,\n  \"yield\": false\n}\n\n/** @desc JavaScript属性方法保留字 */\nexport const jsAttr = {\n  \"Array\": false, \n  \"Date\": false, \n  \"eval\": false, \n  \"function\": false, \n  \"hasOwnProperty\": false,\n  \"Infinity\": false, \n  \"isFinite\": false, \n  \"isNaN\": false, \n  \"isPrototypeOf\": false, \n  \"length\": false,\n  \"Math\": false, \n  \"NaN\": true, \n  \"name\": false, \n  \"Number\": false, \n  \"Object\": false,\n  \"prototype\": false, \n  \"String\": false, \n  \"toString\": false, \n  \"undefined\": false, \n  \"valueOf\": false, \n}\n\n/** @desc window保留字 */\nexport const windowWord = {\n  \"alert\": false, \n  \"all\": false, \n  \"anchor\": false, \n  \"anchors\": false, \n  \"area\": false,\n  \"assign\": false, \n  \"blur\": false, \n  \"button\": false, \n  \"checkbox\": false, \n  \"clearInterval\": false,\n  \"clearTimeout\": false, \n  \"clientInformation\": false, \n  \"close\": false, \n  \"closed\": false, \n  \"confirm\": false,\n  \"constructor\": false, \n  \"crypto\": false, \n  \"decodeURI\": false, \n  \"decodeURIComponent\": false, \n  \"defaultStatus\": false,\n  \"document\": false, \n  \"element\": false, \n  \"elements\": false, \n  \"embed\": false, \n  \"embeds\": false,\n  \"encodeURI\": false, \n  \"encodeURIComponent\": false, \n  \"escape\": false, \n  \"event\": false, \n  \"fileUpload\": false,\n  \"focus\": false, \n  \"form\": false, \n  \"forms\": false, \n  \"frame\": false, \n  \"innerHeight\": false,\n  \"innerWidth\": false, \n  \"layer\": false, \n  \"layers\": false, \n  \"link\": false, \n  \"location\": false,\n  \"mimeTypes\": false, \n  \"navigate\": false, \n  \"navigator\": false, \n  \"frames\": false, \n  \"frameRate\": false,\n  \"hidden\": false, \n  \"history\": false, \n  \"image\": false, \n  \"images\": false, \n  \"offscreenBuffering\": false,\n  \"open\": false, \n  \"opener\": false, \n  \"option\": false, \n  \"outerHeight\": false, \n  \"outerWidth\": false,\n  \"packages\": false, \n  \"pageXOffset\": false, \n  \"pageYOffset\": false, \n  \"parent\": false, \n  \"parseFloat\": false,\n  \"parseInt\": false, \n  \"password\": false, \n  \"pkcs11\": false, \n  \"plugin\": false, \n  \"prompt\": false,\n  \"propertyIsEnum\": false, \n  \"radio\": false, \n  \"reset\": false, \n  \"screenX\": false, \n  \"screenY\": false,\n  \"scroll\": false, \n  \"secure\": false, \n  \"select\": false, \n  \"self\": false, \n  \"setInterval\": false,\n  \"setTimeout\": false, \n  \"status\": false, \n  \"submit\": false, \n  \"taint\": false, \n  \"text\": false,\n  \"textarea\": false, \n  \"top\": false, \n  \"unescape\": false, \n  \"untaint\": false, \n  \"window\": false\n}","import Token, { TOKEN_END, TOKEN_STRING, TOKEN_COMMA, TOKEN_FUNC, TOKEN_CURLY, TOKEN_PAREN, TOKEN_SEMICOLON, TOKEN_VAR, TOKEN_NUMBER, TOKEN_NAME, TOKEN_OPERATOR, TOKEN_SQUARE } from './token';\nimport { TypeToken, TypeCeval } from './interface';\nimport { whitespaceReg, commentReg, stringReg, constsMapReg, number2bitReg, number8bitReg, number10bitReg, number16bitReg, variableReg, operatorReg, unaryMapReg, booleanReg, execFactoryReg, number010bitReg, stringGreedyReg, numberEbitReg } from './utils/regExp';\nimport { jsWord, jsAttr } from './utils/reservedWord';\nimport { contains, isPalindrome, filterUndefine } from './utils/index';\n\n/**\n * 语法解析\n * @class TokenStream\n */\nexport default class TokenStream {\n  // 当前指针下标\n  pos = 0;\n\n  // 当前解析character\n  current: null | TypeToken = null;\n\n  // 暂存指针\n  savedPosition = 0;\n\n  // 暂存解析character，在某些情况下做预判比如, cos是函数，cos() || map(cos) “cos)” 可能被函数parser判定为语法错误\n  savedCurrent: null | TypeToken = null;\n\n  // eslint-disable-next-line\n  constructor(public ceval: TypeCeval, public expression: string) {}\n\n  /**\n   * @desc 获取nextToken，适用语法前置校验\n   * @memberof TokenStream\n   */\n  checkNextAccessGrammar = (): TypeToken => {\n    this.temporarySaved();\n    const next = this.next();\n    this.restore();\n    return next\n  }\n\n  /**\n   * @desc 某些情况下做正则优化，比如 operator 至多3位，所以截取3位再匹配\n   * @param len 获取的长度\n   * @param offset 位移\n   * @see charAt与substr性能对比 https://jsperf.com/substr-or-charat\n   * @memberof TokenStream\n   */\n  getSomeCode = (len = 1, offset = 0): string => {\n    const start = offset + this.pos\n    const { length } = this.expression;\n    // debugger\n    return this.expression.substr(start, (start + len) > length ? length - start : len)\n  }\n\n  /**\n   * @desc 获取首个单词\n   * @memberof TokenStream\n   */\n  getFirstWord = (): string => {\n    const result = this.expression.substr(this.pos).match(/\\b\\w*\\b/)\n    return result ? result[0] : ''\n  }\n\n  /**\n   * 创建新的fieldType实例\n   * @memberof TokenStream\n   */\n  newToken = (type: string, value: any, pos?: number): TypeToken => {\n    return new Token(type, value, pos != null ? pos : this.pos);\n  }\n\n  /**\n   * 解析下一个 field\n   * @memberof TokenStream\n   */\n  next = (): TypeToken => {\n    if (!this.expression.length) {\n      return this.newToken(TOKEN_NAME, \"undefined\")\n    }\n    if (this.pos >= this.expression.length) {\n      return this.newToken(TOKEN_END, 'END');\n    }\n\n    if (this.isWhiteSpace() || this.isComment()) {\n      return this.next()\n    } else if (\n      this.isNumber() ||\n      this.isString() ||\n      this.isBoolean() ||\n      this.isParenthesis() ||\n      this.isComma() ||\n      this.isOperator() ||\n      this.isSemicolon() ||\n      this.isConst() ||\n      this.isVariable() ||\n      this.isFunctionDefined() ||\n      this.isName()\n    ) {\n      return this.current\n    } else {\n      this.parseError(`unknown character: ${this.expression.charAt(this.pos)}`, SyntaxError)\n    }\n  }\n\n  temporarySaved = () => {\n    this.savedPosition = this.pos;\n    this.savedCurrent = this.current;\n  }\n\n  restore = () => {\n    this.pos = this.savedPosition;\n    this.current = this.savedCurrent\n  }\n\n  /**\n   * 过滤空格 \\t \\r \\n\n   * @memberof TokenStream\n   */\n  isWhiteSpace = (): boolean => {\n    const matchWS = whitespaceReg.exec(this.getSomeCode())\n    while (matchWS && matchWS[1]) {\n      this.pos++\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 过滤注释 /*  *\\/\n   * @memberof TokenStream\n   */\n  isComment = (): boolean => {\n    const prefixCm = this.getSomeCode(2);\n    let matchResult: string | undefined\n    if (prefixCm === '/*') {\n      matchResult = execFactoryReg(commentReg, this.getSomeCode(Infinity))\n    } else if(prefixCm === '//') { // comment break line\n      matchResult = execFactoryReg(/^(\\/\\/.*\\n?)/, this.getSomeCode(Infinity));\n    }\n\n    if (matchResult) {\n      this.pos += matchResult.length +(prefixCm === '/*'? (2 + 2):0); // /*matchResult*/\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 过滤空格 \\t \\r \\n\n   * @memberof TokenStream\n   */\n  isBoolean = (): boolean => {\n    const matchWS = booleanReg.exec(this.getSomeCode())\n    while (matchWS && matchWS[1]) {\n      this.pos++\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 申明变量 TODO:support\n   * @memberof TokenStream\n   */\n  isVariable = (): boolean => {\n    const word = this.getFirstWord()\n    if (contains(['const', 'var', 'let'], word)) {\n      this.pos += word.length;\n      this.current = this.newToken(TOKEN_VAR, word)\n      const nextToken = this.checkNextAccessGrammar()\n\n      if (nextToken.type !== TOKEN_NAME) {\n        throw new Error(`${word} ${nextToken.value} : This syntax Not as expected, should be \"${TOKEN_NAME}\", but is \"${nextToken}\"`)\n      } else if(contains(this.ceval.consts, nextToken.value)){\n        throw new SyntaxError(`SyntaxError:  Unexpected token '${nextToken.value}', it has been stated in consts.`)\n      }\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 数字 \n   * @see 说明 需要考虑到 2进制0b10100 === 8进制024 === 10进制20 === 16进制0x14 === 10e0 === 20.000\n   * @memberof TokenStream\n   */\n  isNumber = (): boolean => {\n    const first = this.getSomeCode()\n    let number: string | undefined\n    let bit: number\n    const expr = this.getSomeCode(this.expression.length - this.pos)\n\n    if ((/\\d|\\./.test(first) === false) || (first === '.' && /\\.\\d/.test(this.getSomeCode(2)) === false)) return false\n\n    const [n] = expr.match(/^(0(x|b)+[0-9a-zA-Z]{1,})|(^0?\\d*(\\.\\d+)?)/); // 019 可能会被8进制拦截掉01， 所以必须要做^$\n    number10bitReg.lastIndex = 0;\n    if (first === '0' && n.length > 1 && !(/^0\\.\\d/.test(n))) { // 0.x 不是进制数\n      if (contains(['b', 'x'], this.getSomeCode(1, 1)) && this.getSomeCode(1, n.length) === '.') {\n        // 0b0101.1 0xaf.1 ❌\n        // 099.1 属于十进制 ✅\n        this.parseError(`number '${n}' cannot is a floating point number, but actual is: '${n}${this.getSomeCode(3, n.length)}'`, SyntaxError)\n        return false\n      }\n\n      if (number2bitReg.test(n)) {\n        // 2进制\n        // @see 0b01 0b1110\n        number = execFactoryReg(number2bitReg, n)\n        bit = number === undefined ? undefined : 2\n      } else if (number8bitReg.test(n)) {\n        // 8进制\n        // @see 012 || 077 ✅ \b\n        // @warn 080 || 079 ❌都是十进制  并非8进制\n        number = execFactoryReg(number8bitReg, n)\n        bit = number === undefined ? undefined : 8\n      } else if (number16bitReg.test(n)) {\n        // 16进制 \n        // @see 0xadf\n        number = execFactoryReg(number16bitReg, n)\n        bit = number === undefined ? undefined : 16\n      } else if (number010bitReg.test(n)) {\n        // 0开头十进制 \n        // @see 079 || 080  ✅\n        // @warn 03.1 || 00.1 || 00.  ❌ \n        number = execFactoryReg(number010bitReg, n)\n        bit = number === undefined ? undefined : 10\n      } else {\n        this.parseError('number bitbase parser error', SyntaxError)\n        return false\n      }\n      if (number !== undefined && !this.ceval.getOptions().endableBitNumber) { // 给出准确的warning \n        throw new Error(`options \"endableBitNumber\": You have disabled bitbase number parsing, Not allowed ${number}`)\n      }\n    } else if(numberEbitReg.test(expr)) { // 科学计数法\n      const [, , base, times] = numberEbitReg.exec(expr);\n      number = (Number(base) * Math.pow(10, Number(times))).toString()\n      bit = 10;\n    }else if (number10bitReg.test(expr)) { // 十进制\n      // 100 || 100.1 || 0.1 || .100 || .0  ✅ \n      // parseFloat是支持 0100.1 的。\n      number = execFactoryReg(number10bitReg, expr)\n      bit = number === undefined ? undefined : 10\n    } else {\n      \n      return false\n    }\n\n    if (bit === 10) {\n      this.current = this.newToken(TOKEN_NUMBER, parseFloat(number))\n    } else {\n      this.current = this.newToken(TOKEN_NUMBER, parseInt(number.replace('0b', '').replace('0x', ''), bit))\n    }\n\n    this.pos += number.length\n    return true\n  }\n\n  /**\n   * 字符串\n   * @see '' \\'\\' \\\"\\\" \\\"\\'\\'\\\"\n   * @memberof TokenStream\n   */\n  isString = (): boolean => {\n    const first = this.getSomeCode()\n    const expr = this.getSomeCode(Infinity)\n    let matchString: RegExpExecArray | undefined\n    let strContent: string | undefined\n    if (first === '\\\"' || first === '\\'') {\n      stringGreedyReg.lastIndex = 0;\n        // 一种情况是需要贪婪匹配 \\'\\'a\\'\\', 判断是否需要贪婪匹配\n      matchString = stringGreedyReg.exec(expr)\n      strContent = filterUndefine(matchString[1], matchString[2])\n      if (!isPalindrome(strContent)) {\n        // 不属于回文字符串则需要重新做惰性匹配\n        // 另一种则需要惰性 \"'a', 'b'\" => \"a\"\n        stringReg.lastIndex = 0;\n        matchString = stringReg.exec(expr);\n        strContent = filterUndefine(matchString[1], matchString[2])\n      }\n\n      if (strContent !== undefined) {\n        this.current = this.newToken(TOKEN_STRING, strContent, this.pos)\n        this.pos += (strContent.length + first.length * 2); // \"\" 是没有长度的，会导致Token指针一直处于 \"\" \n        return true\n      }\n    }\n\n    return false\n  }\n\n  isFunctionDefined = (): boolean => {\n    const word = this.getFirstWord();\n    if(word === 'function') {\n      // TODO: 初期只支持 第一种, 同时支持 function fn() {} || const a = () => {} || const b = function(){}\n      this.current = this.newToken(TOKEN_FUNC, undefined);\n      this.pos+=word.length\n      const nextToken = this.checkNextAccessGrammar(); \n      if(nextToken.type !== TOKEN_NAME) {\n        this.parseError('function definition should have function name')\n        return false\n      }\n      return true;\n    }\n    return false\n  }\n  \n  /**\n   * 变量，可能是名称\n   * @see 遵循变量申明规范 可以以 $_ 开头，其他可以是 $_数字字母 ，排除保留字\n   * @memberof TokenStream\n   */\n  isName = (): boolean => {\n    const first = this.getSomeCode()\n    let result\n    if (first === '_' || first === '$' || /^[a-zA-Z]/.test(first)) {\n      variableReg.lastIndex = 0\n      result = variableReg.exec(this.getSomeCode(Infinity))\n    }\n\n    if (result === undefined || result === null || typeof result[1] !== \"string\") {\n      return false\n    }\n\n    result = result[1];\n\n    if (jsWord[result] === false) {\n      // 检测到保留字\n      this.parseError(`parser an reserved word: ${result}`)\n      return false\n    }\n\n    if (jsAttr[result] === false) {\n      // 检测到window属性 TODO: 应该命中 window.xxx\n      this.parseError(`parser an window native attributes or methods: ${result}`)\n      return false\n    }\n\n    this.pos += result.length\n    this.current = this.newToken(TOKEN_NAME, result)\n    return true\n  }\n\n  /**\n   * 内置常量\n   * @see const 例如 true false PI undefined null\n   * @memberof TokenStream\n   */\n  isConst = (): boolean => {\n    constsMapReg.lastIndex = 0;\n    const result = constsMapReg.exec(this.getSomeCode(Infinity))\n\n    if (result && result[1]) {\n      this.current = this.newToken(TOKEN_NAME, result[1])\n      this.pos += result[1].length;\n      const constKey = this.checkNextAccessGrammar();\n      // 检查是否是const常量赋值\n      if(constKey.type === TOKEN_OPERATOR && constKey.value === '=') {\n        this.parseError(`parser error: consts of ${this.current.value} can not assignment;`, SyntaxError)\n      }\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * 分号\n   * @see ;\n   * @memberof TokenStream\n   */\n  isSemicolon = () => {\n    var first = this.getSomeCode();\n    if (first === ';') {\n      this.current = this.newToken(TOKEN_SEMICOLON, ';');\n      this.pos++;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * 逗号,\n   * @see ,\n   * @memberof TokenStream\n   */\n  isComma = () => {\n    var first = this.getSomeCode();\n    if (first === ',') {\n      this.current = this.newToken(TOKEN_COMMA, ',');\n      this.pos++;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * 圆、方括号\n   * @see ;\n   * @memberof TokenStream\n   */\n  isParenthesis = () => {\n    var first = this.getSomeCode();\n    if (contains(['(', ')'], first)) {\n      this.current = this.newToken(TOKEN_PAREN, first);\n    } else if (contains(['[', ']'], first)) {\n      this.current = this.newToken(TOKEN_SQUARE, first);\n    } else if (contains(['{', '}'], first)) {\n      this.current = this.newToken(TOKEN_CURLY, first);\n    } else {\n      return false\n    }\n    this.pos++;\n    return true;\n  };\n\n  /**\n   * 判断是否操作符 \n   * @see 操作符 + - * / || % ^ ? : . > < = >= <= | == === != !== in\n   * @memberof TokenStream\n   */\n  isOperator = (): boolean => {\n    const str = this.getSomeCode(Infinity);\n    let result: string | undefined\n    if (operatorReg.test(str)) {\n      result = execFactoryReg(operatorReg, str)\n    } else if (unaryMapReg.test(str)) {\n      result = execFactoryReg(unaryMapReg, str)\n    }\n    \n    if (!result) return false\n\n    if(this.ceval.getOptions().endableOperators === false) {\n      throw new Error(`options \"endableOperators\": You disabled the operator, Therefore, \"${result}\" it can not be used`)\n    }\n    result = result.replace(/\\s/g, '')\n    this.pos += result.length\n    this.current = this.newToken(TOKEN_OPERATOR, result)\n    return true\n  }\n\n  /**\n   * 获取当前character定位\n   * @memberof TokenStream\n   */\n  getCoordinates = (): { line: number, column: number } => {\n    let line = 0;\n    let column = 0;\n    let index = -1;\n    \n    do {\n      line++;\n      column = this.pos - index;\n      index += 1\n      index += this.expression.substr(index).indexOf('\\n'); // 从每一行第一位开始寻找下一个换行符\n    } while (index >= 0 && index < this.pos && line < this.pos)\n    return {\n      line,\n      column\n    };\n  };\n\n  /**\n   * 解析出错\n   * @memberof TokenStream\n   */\n  parseError = (msg: string, ErrorType: ErrorConstructor | SyntaxErrorConstructor | TypeErrorConstructor = Error) => {\n    var coords = this.getCoordinates();\n    throw new ErrorType('parse error [' + coords.line + ':' + coords.column + '] => ' + msg);\n  };\n\n}","import Instruction, { INSTR_EXPRE, INSTR_FUNCDEF, INSTR_EXECUTBODY, INSTR_VARNAME, INSTR_NAME, INSTR_OBJECT, INSTR_ARRAY, INSTR_FUNCALL, INSTR_MEMBER, INSTR_NUMBER, INSTR_VAR, INSTR_OPERA2, INSTR_PLAIN, INSTR_OPERA3, INSTR_OPERA1 } from './instruction';\nimport Ceval from './index';\nimport { hasAttribute, mapToObject, merge, someCondition, getReference, Reference } from './utils/index';\n\n/**\n * 运算\n * @export calculation\n * @param {Instruction[]} tokens    TokenQueue\n * @param {object} [values={}]      数据池\n * @param {Ceval} ceval             instance of eval\n * @param {boolean} [statis=false]  true全量返回 默认false\n * @param {object} [scope={}]       作用域\n * @returns result or result[]\n */\nexport default function calculation(tokens: Instruction<any>[], values = Object.create(null), ceval: Ceval, statis = false, scope = Object.create(null)) {\n  if (window.name) {\n   console.group('calclation Dev')\n    console.log('tokens: ', tokens);\n    console.log('values', values)\n    console.log('scope', scope)\n   console.groupEnd()\n  }\n  const options = ceval.getOptions();\n  const { unaryOps, binaryOps, ternaryOps } = ceval\n  const stack = [];\n  const { length } = tokens;\n  let n1, n2, n3;\n  let fn: undefined | Function | Instruction<CustomFunc>\n  for (let i = 0; i < length; i++) {\n    const item = tokens[i];\n    const { type, value } = item || {};\n\n    if (!type) {\n      stack.push(item)\n      continue\n    }\n    switch(type) {\n      case INSTR_NUMBER: \n      case INSTR_PLAIN:\n      case INSTR_VARNAME: {\n        stack.push(value);\n        break\n      }\n      case INSTR_NAME: {\n        // 变量名称，范围作用域有functions consts values _scope 后者优先\n        if (hasAttribute(scope, value)) {\n          // scope,作用域\n          stack.push(scope[value])\n        } else if (hasAttribute(values, value)) {\n          // customVal\n          stack.push(values[value])\n        } else if (hasAttribute(ceval.consts, value)) {\n          // 常量\n          stack.push(ceval.consts[value])\n        } else if(hasAttribute(ceval.functions, value)) {\n          // 内置函数\n          stack.push(ceval.functions[value])\n        } else {\n          throw new Error(`${value} is not defined in values or consts`)\n        }\n        break\n      }\n      case INSTR_OPERA1: {\n        if(stack.length === 0) break;\n        // 一元运算，需要一个操作数\n        [n1] = stack.splice(-1, 1);\n        fn = specifyAttr<Function>(value, [values, unaryOps], options.allowOperatorsCovered)\n        \n        stack.push(fn(n1));\n        // 当操作符是return 时，终止该运算循环\n        if(value === 'return') {\n          i = length\n        }\n        break\n      }\n      case INSTR_OPERA2: { // 二元运算，需要有两个操作数\n        if(stack.length < 2) break;\n        [n1, n2] = stack.splice(-2, 2)\n          fn = specifyAttr<Function>(value, [values, binaryOps], options.allowOperatorsCovered)\n        if (value === '&&') { // 1&&0&&3可能是连续的\n          stack.push(fn(n1, calculation([n2], values, ceval, statis, scope), false)); // true && true && false\n        } else if (value === '=') {\n          // 写操作分为属性赋值和引用赋值\n          if(n1 instanceof Reference) { // left hide 为引用\n            n1.setValue(n2);\n            n1.destory();\n          } else {\n            someCondition(hasAttribute(scope, n1), hasAttribute(values, n1), `${n1} is not define in values or current scope, if you are declaring a new variable, please add var, const or let operator`)\n            fn(n1, n2, hasAttribute(scope, n1) ? scope : values)\n          // 如果当前作用域含有该属性，作用域优先\n          }\n        } else {\n          stack.push(fn(n1, calculation([n2], values, ceval, statis, scope), options));\n        }\n        break\n      }\n      case INSTR_OPERA3: { // 三元运算，需要有三个操作数\n        if(stack.length < 3) break;\n        [n1, n2, n3] = stack.splice(-3, 3)\n        fn = specifyAttr<Function>(value, [values, ternaryOps], options.allowOperatorsCovered)\n        stack.push(fn(n1, n2, n3));\n        break\n      }\n      case INSTR_EXPRE: { // 表达式\n        stack.push(calculation(item.value, values, ceval, statis, scope))\n        break;\n      }\n      case INSTR_MEMBER: { // 成员访问\n        // 有可能是读，也有可能是写；\n        const nextItem = tokens[i+2]; // 解析顺序 INSTR_MEMBER => INSTR_EXPRE => INSTR_OP2\n        const ref = getReference(value, scope, values)\n        \n        if(nextItem && nextItem.type === INSTR_OPERA2 && nextItem.value === '=') {\n          // 写操作, JavaScript是拿不到引用的，push到stack，等待引用赋值\n          stack.push(ref)\n        } else {\n          stack.push(ref.getValue())\n          ref.destory();\n        }\n        \n        break\n      }\n      case INSTR_ARRAY: { // 数组字面量\n        stack.push(calculation(value, values, ceval, true, scope))\n        break\n      }\n      case INSTR_OBJECT: { // 对象字面量\n        const instr = Object.create(null)\n        Object.keys(value).forEach(key => {\n          instr[key] = calculation(value[key], values, ceval, statis,scope)\n        })\n        stack.push(instr)\n        break\n      }\n      case INSTR_VAR: { // 赋值语句\n        [n1, n2] = stack.splice(-2, 2)\n        switch (value) {\n          case 'let':\n          case 'const': {\n            // let const的行为待定义, let 和 const 应该挂载到作用域上，而var 可以赋给 values \n            // TODO: 需要判定assgin给scope还是values\n            if (hasAttribute(scope, n1)) {\n              console.warn(`${n1} already statement in consts or scope`)\n            }\n            scope[n1] = n2;\n            break\n          }\n          case 'var': {\n            values[n1] = n2; \n            break\n          }\n          default: {\n            console.warn('Unexpected statement identifier')\n            break;\n          }\n        }\n        break\n      }\n      case INSTR_FUNCALL: { // 自声明函数调用，区分是外部函数还是内声明函数\n        const args = stack.splice(-value, value);\n        fn = stack.pop();\n        // if(args.length !== value) {} // TODO: 参数不够的情况 warning\n        if (typeof fn === 'function') {\n          // 外置函数，即在consts内声明的\n          stack.push(fn.apply(null, args))\n          continue\n        } else if(fn.value instanceof CustomFunc) { // 内置函数\n          fn.value.updateScope(args)\n          stack.push(fn.value.invokeBody())\n        }\n        break\n      }\n      case INSTR_FUNCDEF: { // 函数定义\n        if (typeof value !== 'string') {\n          stack.push(value); // 函数体\n          continue\n        }\n        if (stack.length === 0) return\n        const _scope = merge(Object.create(null), scope); // 作用域\n  \n        // done: 嵌套函数区分, 挂载到当前_scope上\n        _scope[value] = new Instruction<CustomFunc>(INSTR_EXECUTBODY, new CustomFunc(stack.pop(), values, _scope, ceval))\n  \n        Object.assign(scope, _scope)\n        break\n      }\n      default: {\n        const _val = Symbol('_init') // 值可能就是undefined，做区分\n        let val = _val\n        try {\n          val = item.value\n        } catch (e) {\n          // item = undefined | null | false | true ....\n        }\n        if (val !== _val) {\n          stack.push(val)\n        }\n      }\n    }\n  }\n  return statis ? stack : stack[0];\n}\n\nfunction specifyAttr<T>(value: string, [customValues, defaultValues], shouldCustom = false): T {\n  let fn: T\n  if(shouldCustom && hasAttribute(customValues, value)) {\n    fn = customValues[value] as T;\n  } else {\n    fn = defaultValues[value] as T;\n  }\n  return fn\n};\n\n// class Data {\n//   constructor()\n// }\n\nclass CustomFunc {\n  args: string[];\n\n  constructor(public func: Instruction<any>[], public values: Record<string, any>, public _scope: Record<string, any>, public ceval: Ceval) {\n    const args = this.func.splice(0, func.length - 1)\n    this.args = calculation(args, mapToObject(args, (k) => k), ceval, true)\n    this._scope = merge(mapToObject(args), _scope);\n  }\n\n  updateScope = (scope: any[]) => {\n    // 假设 Object attribute 是不保证顺序的。\n    this.args.forEach((key, index) => {\n      if(hasAttribute(this._scope, key)) {\n        this._scope[key] = scope[index]\n      }\n    });\n  }\n\n  invokeBody = () => {\n    return calculation(this.func, this.values, this.ceval, false, this._scope)\n  }\n}\n","import { getTime } from './index';\n\nconst [date, time] = getTime()\n\nexport default {\n  now: Date.now(),\n  date,\n  time,\n}","import Parser from './parser';\nimport Ceval from './index';\nimport Token from './token';\nimport TokenStream from './token-stream';\nimport Instruction from './instruction';\n\nexport type TypeParser = InstanceType<typeof Parser>\n\nexport type TypeCeval = InstanceType<typeof Ceval>\n\nexport type TypeToken = InstanceType<typeof Token>\n\nexport type TypeTokenStream = InstanceType<typeof TokenStream>\n\nexport type TypeInstruction = Instruction<any>\n\nexport type KeyOfValType<T extends object> = T[keyof T];\n\nexport class CevalOptions {\n  /**\n   * @desc 允许使用运算符\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  endableOperators?: boolean = true;\n\n  /**\n   * @desc 允许启用多位进制Number\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  endableBitNumber?: boolean = true;\n\n  /**\n   * @desc 允许访问成员\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  allowMemberAccess?: boolean = true;\n\n  /**\n   * @desc 允许默认放大计算，以处理四则运算的结果 e.g 0.1+0.2 !== 0.3  || 1.0-0.9 !== 0.1\n   * 在超出边界的情况下（ta > Number.MAX_SAFE_INTEGER || ta < Number.MIN_SAFE_INTEGER）会不做处理，还原四则运算\n   * @requires false \n   * @type {boolean}\n   */\n  allowHandleNumberPrecision?: boolean = true;\n\n  /**\n   * @desc 默认不允许操作符被 presetValue 覆盖\n   * @see 某些情况下开发者想制定更加精确的计算,例如BigInt,那么就在根据operatorMap声明presetValue={'+':Function}\n   * @requires false\n   * @type {boolean}\n   * @memberof CevalOptions\n   */\n  allowOperatorsCovered?: boolean = false;\n  \n  /**\n   * @desc 当没有返回值或为undefined时触发默认返回值\n   * @requires false\n   * @todo done\n   * @type {any}\n   */\n  defaultReturnValues?: any = '' // done\n}","import cloneDeep from 'lodash/cloneDeep'\nimport Parser from './parser';\nimport systemMap, { TypeUnary, TypeBinary, TypeTernary, TypeConst, TypeFunction, operatorMap } from './systemMap';\nimport TokenStream from './token-stream';\nimport calculation from './calculation';\nimport presetVariable from './utils/presetVariable';\nimport { merge } from './utils/index';\nimport { CevalOptions, TypeInstruction } from './interface';\n\nexport default class Ceval {\n  unaryOps: TypeUnary;\n\n  binaryOps: TypeBinary;\n\n  ternaryOps: TypeTernary;\n\n  consts: TypeConst;\n\n  functions: TypeFunction;\n\n  /**\n   * 操作符映射表，可做在presetValues覆盖运算\n   */\n  operatorMap = operatorMap;\n\n  private currentValues: Record<string, any> = cloneDeep(presetVariable);\n\n  constructor(private options: Readonly<CevalOptions> = {}) {\n    Object.assign(this, systemMap);\n    merge(this.options, new CevalOptions())\n  }\n\n  /**\n   * 查询支持的操作符方法名称, 可做覆盖\n   * @param ops 操作符\n   * @memberof Ceval\n   */\n  getSupportOperationMap = (ops: string): null | Function => {\n    return Object.prototype.hasOwnProperty.call(operatorMap, ops) ? operatorMap[ops] : null\n  }\n\n  /**\n   * 解析字符串，对外暴露方法\n   * @memberof Ceval\n   */\n  parseString = (expression: string, values: Record<string, any> = {}) => {\n    const instr: TypeInstruction[] = [];\n    const isDev = process.env.NODE_ENV !== 'development';\n    let value\n    if(isDev) {\n        Parser.generatorParser(this, new TokenStream(this, expression), instr)\n        value = this.injectValueToCalc(instr, values)\n    } else {\n      try {\n        Parser.generatorParser(this, new TokenStream(this, expression), instr)\n        value = this.injectValueToCalc(instr, values)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    return value\n  }\n\n  /**\n   * 获取当前数据池 预置+外置+内声明\n   * @returns 数据池\n   * @memberof Ceval\n   */\n  getCurrentValues = (): Record<string, any> => cloneDeep(this.currentValues);\n\n  /**\n   * 传入指令集开始计算\n   * @param {tokens} Instruction[] 指令集\n   * @param {Record<string, any>} [values={}] 数据池\n   * @memberof Ceval\n   */\n  private injectValueToCalc = (tokens: TypeInstruction[], values: Record<string, any> = {}): any => {\n    // @TODO 检查敏感字\n    // @TODO 检查关键字\n    this.updatePresetValues(values);\n    const result = calculation(tokens, this.currentValues, this)\n    return result === undefined ? this.options.defaultReturnValues : result\n  }\n\n  /**\n   * Update PresetValues\n   * @param {values} Record<string, any> 配置\n   * @memberof Ceval\n   */\n  updatePresetValues = (values: Record<string, any>): void => {\n    Object.assign(this.currentValues, values)\n  }\n\n  /**\n   * Update Option\n   * @param {Options} CevalOptions 配置\n   * @memberof Ceval\n   */\n  updateOptions = (Options: Partial<CevalOptions>): void => {\n    Object.assign(this.options, Options)\n  }\n\n  /**\n   * get Options\n   * @memberof Ceval\n   */\n  getOptions = () => {\n    return cloneDeep(this.options);\n  }\n\n} "],"names":["Instruction","[object Object]","type","value","this","TOKEN_END","TOKEN_COMMA","TOKEN_NAME","TOKEN_SEMICOLON","Token","index","window","_debug","console","log","toString","Object","prototype","isObject","obj","call","contains","source","hasOwnProperty","Array","isArray","some","v","indexOf","merge","target","keys","forEach","key","val","filterUndefine","args","one","item","undefined","hasAttribute","name","mapToObject","arr","defaultValue","length","Set","Error","join","create","someCondition","errMsg","pop","find","d","getReference","keyQueue","scope","values","path","shift","lastKey","TypeError","Reference","destoryed","getDigitLength","num","split","checkBounds","number","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getBaseNum","a","b","baseNum","Math","pow","max","unwantedHandlePercision","isInteger","system","functions","random","min","apply","f","map","x","i","consts","E","PI","true","false","null","NaN","Infinity","binaryOps","+","options","allowHandleNumberPrecision","round","-","*","/","%","^","||","n1","n2","&&","==","!=","!==",">","<",">=","<=","=","variables","[","array","===","in","String","eliminateQuote","str","quoteReg","test","result","exec","ternaryOps","?","cond","yep","nope","unaryOps","!","~","++","--","typeof","_typeof","match","toLowerCase","return","sin","cos","tan","syntaxOperator",":",".","excludeOperator","operatorMap","mapVal","data","object","cb","maps","includes","BLACK_LIST_OPERATORS","supportOperator","from","concat","filter","op","sort","whitespaceReg","booleanReg","commentReg","stringReg","stringGreedyReg","number2bitReg","number8bitReg","number010bitReg","number10bitReg","number16bitReg","numberEbitReg","variableReg","operatorReg","RegExp","r","unaryMapReg","unarySymbolMapReg","constsMapReg","k","execFactoryReg","reg","expr","lastIndex","isUnaryOpeator","Parser","ceval","tokens","exprInstr","len","expression","parseExpression","current","nextToken","next","matchToken","accept","line","column","getCoordinates","printLog","error","savedCurrent","savedNextToken","temporarySaved","restore","instr","parseMultipleEvaluation","exp","push","parseAssignmentExpression","parseConditionalExpression","ident","parseOrExpression","trueBranch","falseBranch","expect","parseAndExpression","branch","parseBitwiseOrExpression","parseBitwiseAndExpression","parseEqualExpression","parseCompareExpression","parseInOrAtExpression","parseBitwiseMoveExpression","parseAddOrSubExpression","parseMulOrDivExpression","parseUnaryExpression","parseField","parseOuterFunctionCallExpression","parseMemberAccessExpression","parseArguments","count","refPath","currentItem","getOptions","allowMemberAccess","parseArrayLiteralDeclaration","parseObjectLiteralDeclaration","identifier","parseFunctionDefinedDeclaration","expreInstr","funcName","parseFunctionBodyExpression","SyntaxError","msg","tip","c","inspectParseEnd","parser","jsWord","abstract","arguments","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","eval","export","extends","final","finally","float","for","function","goto","if","implements","import","instanceof","int","interface","let","long","native","new","package","private","protected","public","short","static","super","switch","synchronized","throw","throws","transient","try","var","void","volatile","while","with","yield","jsAttr","Date","isFinite","isNaN","isPrototypeOf","valueOf","TokenStream","offset","start","pos","substr","newToken","isWhiteSpace","isComment","isNumber","isString","isBoolean","isParenthesis","isComma","isOperator","isSemicolon","isConst","isVariable","isFunctionDefined","isName","parseError","charAt","savedPosition","matchWS","getSomeCode","prefixCm","matchResult","word","getFirstWord","checkNextAccessGrammar","first","bit","n","endableBitNumber","base","times","parseFloat","parseInt","replace","matchString","strContent","surplusStr","substring","isPalindrome","constKey","endableOperators","ErrorType","coords","calculation","statis","group","groupEnd","stack","n3","fn","splice","specifyAttr","allowOperatorsCovered","setValue","destory","nextItem","ref","getValue","warn","CustomFunc","updateScope","invokeBody","_scope","assign","_val","Symbol","e","customValues","defaultValues","shouldCustom","func","date","time","o","now","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","t","getTime","CevalOptions","cloneDeep","presetVariable","ops","process","env","NODE_ENV","generatorParser","injectValueToCalc","currentValues","updatePresetValues","defaultReturnValues","Options","systemMap"],"mappings":"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"}