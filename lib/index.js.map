{"version":3,"file":"index.js","sources":["../src/instruction.ts","../src/token.ts","../src/utils/index.ts","../src/utils/functions.ts","../src/systemMap.ts","../src/utils/regExp.ts","../src/parser.ts","../src/utils/reservedWord.ts","../src/token-stream.ts","../src/calculation.ts","../src/utils/presetVariable.ts","../src/interface.ts","../src/index.ts"],"sourcesContent":["/** @desc 一元运算符 */\nexport const INSTR_OPERA1 = 'INSTR_OP1';\n/** @desc 二元运算符 */\nexport const INSTR_OPERA2 = 'INSTR_OP2';\n/** @desc 三元运算符 */\nexport const INSTR_OPERA3 = 'INSTR_OP3';\n\n/** @desc 数字 */\nexport const INSTR_NUMBER = 'INSTR_NUMBER';\n/** @desc 数组字面量 */\nexport const INSTR_ARRAY = 'INSTR_ARRAY';\n/** @desc 对象字面量 */\nexport const INSTR_OBJECT = 'INSTR_OBJECT';\n/** @desc 简单类型，表示不用处理 */\nexport const INSTR_PLAIN = 'INSTR_PLAIN';\n\n/** @desc 对象成员访问 */\nexport const INSTR_MEMBER = 'INSTR_MEMBER';\n\n/** @desc 表达式, 内置表达式 */\nexport const INSTR_EXPRE = 'INSTR_EXPRE';\n\n/** @desc 变量类型 const let var */\nexport const INSTR_VAR = 'INSTR_VAR';\n/** @desc 变量名称, 区别是内声明 TODO: var obj = {} */\nexport const INSTR_VARNAME = 'INSTR_VARNAME';\n/** @desc 变量名称, 取值, 没有经过声明的名称，例如 undefined, null, 以及数据池中的数据 */\nexport const INSTR_NAME = 'INSTR_NAME';\n\n/** @desc 函数调用 */\nexport const INSTR_FUNCALL = 'INSTR_FUNCALL'; // TODO: 函数声明\n/** @desc 函数定义指令 */\nexport const INSTR_FUNCDEF = 'INSTR_FUNCDEF';\n/** @desc 函数执行体 */\nexport const INSTR_EXECUTBODY = 'INSTR_EXECUTBODY';\n\n\n/**\n * @desc 指令实例\n */\nexport default class Instruction<T extends any> {\n\n  value: T;\n\n  constructor(public type: string, value?: any) {\n    this.value = (value !== undefined && value !== null) ? value : 0;\n  }\n}\n\n","/** @desc 结束标记 */\nexport const TOKEN_END = 'TOKEN_END';\n/** @desc 操作符类型 */\nexport const TOKEN_OPERATOR = 'TOKEN_OP';\n/** @desc 数字类型 */\nexport const TOKEN_NUMBER = 'TOKEN_NUMBER';\n/** @desc 字符串类型 */\nexport const TOKEN_STRING = 'TOKEN_STRING';\n/** @desc 圆括号，调用 */\nexport const TOKEN_PAREN = 'TOKEN_PAREN';\n/** @desc 方括号，成员访问 [] */\nexport const TOKEN_SQUARE = 'TOKEN_SQUARE';\n/** @desc 花括号，字面量声明 */\nexport const TOKEN_CURLY = 'TOKEN_CURLY';\n/** @desc 逗号 , */\nexport const TOKEN_COMMA = 'TOKEN_COMMA';\n/** @desc 变量 , */\nexport const TOKEN_VAR = 'TOKEN_VAR';\n/** @desc 变量名称 */\nexport const TOKEN_NAME = 'TOKEN_NAME';\n/** @desc 函数定义 */\nexport const TOKEN_FUNC = 'TOKEN_FUNC';\n/** @desc 结束标记; */\nexport const TOKEN_SEMICOLON = 'TOKEN_SEMICOLON';\n\n/**\n * tokenStream 解析阶段指令\n * @export \n * @class Token\n */\nexport default class Token {\n  constructor(public type: string, public value: any, public index: number) {\n    this.toString = this.toString.bind(this);\n  }\n\n  toString = () => {\n    return this.type + ': ' + this.value;\n  };\n}\n\n","import Instruction from '../instruction';\n\nconst { toString } = Object.prototype;\n\n\nexport function isObject(obj): obj is object {\n  return toString.call(obj) === '[object Object]'\n}\n\n/**\n * @export\n * @template T\n * @param {array|object|string} source \n * @param {string} value\n * @returns {boolean}\n */\nexport function contains(source: any[] | Record<any, any> | string, value: string): boolean {\n  if (isObject(source)) {\n    return Object.prototype.hasOwnProperty.call(source, value)\n  } else if (Array.isArray(source)) {\n    return source.some(v => v === value)\n  }\n  return source.indexOf(value) > -1\n}\n\n/**\n * 获取日期时间\n * @export getTime\n * @param {number} [offset=0] 偏移量\n * @returns {string[]} [date, time]\n */\nexport function getTime(offset = 0): string[] {\n  const o = new Date(Date.now() + offset);\n  const date = `${o.getFullYear()}-${o.getMonth() + 1}-${o.getDate()}`\n  const clock = `${o.getHours()}:${o.getMinutes()}:${o.getSeconds()}`.replace(/\\d+/g, (t) => {\n    return parseInt(t, 10) < 10 ? `0${t}` : t\n  })\n\n  return [date, clock]\n}\n\n\n/**\n * 递归foreach\n * @export mapVal\n * @template T\n * @param {T} data\n * @param {Record<string, Record<string, any>>} object\n * @param {(data: T, key:string, val: any) => void} cb\n * @returns\n */\nexport function mapVal<T extends object>(data: T, object: object, cb: (data: T, key: string, val: any) => void) {\n  Object.keys(object).map(key => {\n    return isObject(object[key]) ? mapVal(data, object[key], cb) : cb(data, key, object[key])\n  })\n  return data\n}\n\n/**\n * 前者为主，仅合并不存在属性\n * @template T object\n * @param {T} target\n * @param {T} source\n */\nexport function merge<T>(target: T, source: T) {\n  Object.keys(source).forEach(key => {\n    const val = source[key]\n    if (Object.prototype.hasOwnProperty.call(target, key)) return\n    if (Array.isArray(val)) {\n      merge(target[key] = [], val)\n    } else if (isObject(val)) {\n      merge(target[key] = {}, val)\n    } else {\n      target[key] = val\n    }\n  })\n  return target\n}\n\n/**\n * 替换\\'\\' \\\"\\\" 在 处理 in operator 需要到\n * @param {string} str string Field\n * @returns {string} 没有对称引号的字符串\n */\nexport function eliminateQuote(str: string): string {\n  const quoteReg = /^\\\"(.*)\\\"$|^\\'(.*)\\'$/;\n  if (!quoteReg.test(str)) return str\n  const result = quoteReg.exec(str)\n  const s = result[1] !== undefined ? result[1] : result[2]\n  return eliminateQuote(s)\n}\n/**\n * 回文字符串 \\'\\'a\\'\\' ✅  \\'\\'a\\'❌\n * @param {string} str\n * @returns\n */\nexport function isPalindrome(str: string) {\n  let i = 0\n  while (contains(['\\'', '\\\"'], str.charAt(i)) && str.charAt(i) === str.charAt(str.length - 1 - i)) {\n    i++\n  }\n  const surplusStr = str.substring(i, str.length - i)\n  return surplusStr.indexOf('\\\"') === -1 && surplusStr.indexOf('\\'') === -1\n}\n\n/**\n * 返回首个有效数据， 非undefined null false true\n * @param {*} args\n */\nexport function filterUndefine(...args) {\n  let one\n  args.some(item => {\n    if (contains([undefined, null, true, false], item)) return false\n    one = item\n    return true;\n  })\n  return one\n}\n\n\nexport function hasAttribute(obj: object, name: string) {\n  return Object.prototype.hasOwnProperty.call(obj, name)\n}\n\nexport function unique(source:any[]) {\n  const arr = [];\n  source.forEach(element => {\n    if (arr.indexOf(element) === -1) arr.push(arr);\n  });\n  return arr\n}\n\n/**\n * Array to Object e.g. ['a', 'b'] => { a: undefined, b: undefined }\n * @param {string[]} arr \n */\nexport function mapToObject(arr: string[] | Instruction<any>[], defaultValue: undefined | ((key: string) => any) = undefined) {\n  if (typeof arr[0] === 'string' && arr.length !== unique(arr).length) {\n    // 参数重复\n    throw new Error(`Duplicate parameter: ${arr.join(',')}`)\n  }\n  const obj = Object.create(null)\n  arr.forEach((item) => {\n    let key\n    if (item instanceof Instruction) {\n      key = item.value\n    } else {\n      key = item\n    }\n    obj[key] = (typeof defaultValue === 'function' ? defaultValue(key) : defaultValue)\n  })\n  return obj\n}\n\nexport function someCondition(...args) {\n  const errMsg = args.pop();\n\n  if (!args.find(d => !!d)) {\n    throw new Error(errMsg)\n  }\n}\n/**\n * \n * @param keyQueue [\"obj\", \"arr\"] key path\n * @param scope 当前作用域\n * @param values 顶层作用域\n */\nexport function getReference(keyQueue: string[], scope: Record<string, any>, values: Record<string, any>): Reference {\n  if (keyQueue.length < 2) return hasAttribute(scope, keyQueue[0]) ? scope[keyQueue[0]] : values[keyQueue[0]];\n  let path = keyQueue.shift();\n  const lastKey = keyQueue.pop();\n  let target = hasAttribute(scope, path) ? scope : values;\n  while (path) {\n    if (hasAttribute(target, path)) {\n      target = target[path];\n    } else if (!target) {\n      throw new TypeError(`Uncaught TypeError: Cannot read property '${path}' of ${target}`)\n    } else {\n      target = undefined\n    }\n    path = keyQueue.shift()\n  }\n  return new Reference(target, lastKey)\n}\n\nexport class Reference {\n  destoryed: boolean;\n\n  constructor(public target: any, public path: string) {\n    this.destoryed = false\n  }\n\n  setValue(value) {\n    if(this.destoryed) return value\n    return (this.target[this.path] = value)\n  }\n\n  getValue() {\n    if(this.destoryed) return undefined\n    return this.target[this.path]\n  }\n\n  destory() {\n    // 使用一次就释放掉内存\n    this.destoryed = true\n    this.target = null;\n  }\n}","import { contains, isObject, eliminateQuote } from './index';\nimport { CevalOptions } from '../interface';\n\nfunction getDigitLength(num: number){\n  return (num.toString().split('.')[1] || '').length;\n}\n\nfunction checkBounds(number: number) {\n  return number > Number.MAX_SAFE_INTEGER || number < Number.MIN_SAFE_INTEGER\n}\n\nfunction getBaseNum(a: number, b: number): number {\n  const baseNum = Math.pow(10, Math.max(getDigitLength(a), getDigitLength(b)));\n  if(checkBounds(a * baseNum) || checkBounds(b * baseNum)) { // 超出边界的情况不予处理\n    return 0\n  }\n  return baseNum\n}\n\nconst unwantedHandlePercision = (a, b) => {\n  // 整数不需要处理 || 非Number也不需要\n  return (Number.isInteger(a) && Number.isInteger(b)) || (typeof a !== 'number' || typeof b !== 'number')\n}\n\nexport function add(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a + b\n  const baseNum = getBaseNum(a,b);\n  return baseNum === 0 ? a + b : (Math.round(a * baseNum) + Math.round(b * baseNum)) / baseNum \n}\n\nexport function sub(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a - b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a - b : (Math.round(a * baseNum) - Math.round(b * baseNum)) / baseNum;\n}\n\nexport function mul(a: number, b: number, options: CevalOptions): number {\n  if(options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a * b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a * b : (Math.round(a * baseNum) * Math.round(b * baseNum)) / Math.pow(baseNum, 2);\n}\n\nexport function divide(a: number, b: number, options: CevalOptions): number {\n  if( options.allowHandleNumberPrecision === false || unwantedHandlePercision(a,b)) return a / b\n  const baseNum = getBaseNum(a,b)\n  return baseNum === 0 ? a / b : (Math.round(a * baseNum) / Math.round(b * baseNum));\n}\n\nexport function mod(a, b) {\n  return a % b;\n}\n\nexport function equal(a, b) {\n  // eslint-disable-next-line\n  return a == b;\n}\n\nexport function strictEqual(a, b) {\n  return a === b;\n}\n\nexport function notEqual(a, b) {\n  // eslint-disable-next-line\n  return a != b;\n}\n\nexport function strictNotEqual(a, b) {\n  return a !== b;\n}\n\nexport function greaterThan(a, b) {\n  return a > b;\n}\n\nexport function lessThan(a, b) {\n  return a < b;\n}\n\nexport function greaterThanEqual(a, b) {\n  return a >= b;\n}\n\nexport function _typeof(a){\n  return Object.prototype.toString.call(a).match(/^\\[object\\s*(\\w+?)\\]$/)[1].toLowerCase()\n}\n\nexport function lessThanEqual(a, b) {\n  return a <= b;\n}\n\nexport function inTheTarget(a, b) {\n  if(typeof b !== 'object' || String(a) !== `${a}` ) throw new Error('first argument must be original type, second must be Array or Object')\n  return isObject(b) ? Object.prototype.hasOwnProperty.call(b, eliminateQuote(a)) : contains(b, a)\n}\n\nexport function bitWiseOr(a, b) {\n  return a ^ b\n}\n\nexport function setVar(name: string | number, value: any, variables: object | Array<any> ) {\n  if (variables) variables[name] = value;\n  return value;\n}\n\nexport function arrayIndex(array, index) {\n  return array[index | 0];\n}\n\nexport function condition(cond, yep, nope) {\n  return cond ? yep : nope;\n}\n\nexport function withOr(n1, n2) {\n  return n1 ? n1 : n2\n}\n\nexport function withAlso(n1, n2) {\n  return n1 ? n2 : n1\n}\n\nexport function max(...args: number[]) {\n  if (args.length === 1) {\n    return Math.max.apply(Math, args);\n  } else {\n    return Math.max.apply(Math, args);\n  }\n}\n\nexport function min(...args: number[]) {\n  if (args.length === 1) {\n    return Math.min.apply(Math, args);\n  } else {\n    return Math.min.apply(Math, args);\n  }\n}\n\nexport function arrayMap(f: (val: any, index?: number) => any, a: any[]) {\n  if (typeof f !== 'function') {\n    throw new Error('First argument is not a function');\n  }\n  if (!Array.isArray(a)) {\n    throw new Error('Second argument is not an array');\n  }\n  return a.map(function (x, i) {\n    return f(x, i);\n  });\n}\n\nexport function random(a) {\n  return Math.random() * (a || 1);\n}\n\nfunction decimalAdd(num1, num2) {\n  const num1Digits = (num1.toString().split('.')[1] || '').length;\n  const num2Digits = (num2.toString().split('.')[1] || '').length;\n  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}","import { mapVal } from './utils/index';\nimport {\n  // 功能性\n  random, min, max, arrayMap as map, _typeof,\n  // 二元\n  add, sub, mul, divide, mod, withOr, withAlso, equal, notEqual, greaterThan, lessThan, greaterThanEqual, lessThanEqual, inTheTarget, setVar, arrayIndex, bitWiseOr, strictNotEqual,\n  // 三元\n  condition,\n  strictEqual\n} from './utils/functions';\n\nconst system = {\n  functions: {\n    random,\n    min,\n    max,\n    map,\n    pow: Math.pow,\n  },\n  consts: {\n    E: Math.E,\n    PI: Math.PI,\n    'true': true,\n    'false': false,\n    \"undefined\": undefined,\n    \"null\": null,\n    \"NaN\": Number.NaN,\n    \"Infinity\": Infinity,\n    \"Map\": Object.create(null)\n  },\n  binaryOps: {\n    '+': add,\n    '-': sub,\n    '*': mul,\n    '/': divide,\n    '%': mod,\n    '^': bitWiseOr,\n    '||': withOr,\n    '&&': withAlso,\n    '==': equal,\n    '!=': notEqual,\n    '!==': strictNotEqual,\n    '>': greaterThan,\n    '<': lessThan,\n    '>=': greaterThanEqual,\n    '<=': lessThanEqual,\n    '=': setVar,\n    '[': arrayIndex,\n    '===': strictEqual,\n    'in': inTheTarget,\n    // 'instanceOf' // 没必要做这个 Object都访问不了的\n  },\n  ternaryOps: {\n    '?': condition\n  },\n  unaryOps: {\n    '+': (v): number => +v,\n    '-': (v): number => -v,\n    '!': (v): boolean => !v,\n    '~': (v): number => ~v,\n    '++': (v): number => v += 1,\n    '--': (v): number => v -= 1,\n    'typeof': (v): string => _typeof(v),\n    'return': v => v,\n    sin: Math.sin,\n    cos: Math.cos,\n    tan: Math.tan,\n  },\n  syntaxOperator: {\n    ':': null,\n    '.': null,\n  }\n}\n\nObject.defineProperty(system.consts, 'Map', {\n  get:() => Object.create(null)\n})\n\nexport default system;\n\n/** @desc 功能函数 */\nexport type TypeFunction = typeof system.functions;\n/** @desc 常量设置 */\nexport type TypeConst = typeof system.consts;\n/** @desc 一元运算符 */\nexport type TypeUnary = typeof system.unaryOps;\n/** @desc 二元运算符 */\nexport type TypeBinary = typeof system.binaryOps;\n/** @desc 三元运算符 */\nexport type TypeTernary = typeof system.ternaryOps;\n/** @desc 词法操作符 */\nexport type TypeSyntax = typeof system.syntaxOperator;\n\n// 有些运算符不能被修改。\nconst excludeOperator = ['=', '['];\n\n/** @desc 运算符映射表 */\nexport const operatorMap = Object.assign(mapVal(Object.create(null), {\n  binaryOps: system.binaryOps,\n  unaryOps: system.unaryOps,\n  ternaryOps: system.ternaryOps,\n}, (maps, key, val) => {\n  if(!excludeOperator.includes(key)) {\n    maps[key] = val\n  }\n}), { \n  functions: system.functions,\n  consts: system.consts\n})","/** \n * @desc   : desc \n * @author : ziwen\n * @date   : 2020-6-2 10:55:30\n */\nimport system from '../systemMap';\nimport { contains } from './index';\n\nconst BLACK_LIST_OPERATORS = []\nconst supportOperator = Array.from(new Set(\n  [].concat(\n    Object.keys(system.unaryOps).filter(item => !/\\b\\w+\\b/.test(item)),\n    Object.keys(system.binaryOps),\n    Object.keys(system.ternaryOps),\n    Object.keys(system.syntaxOperator)\n  )\n    .filter(op => !contains(BLACK_LIST_OPERATORS, op))\n    .sort((a, b) => b.length - a.length)\n))\n\nexport const whitespaceReg = /(\\t|\\n|\\r|\\s+)/;\nexport const booleanReg = /^(false|true)/;\nexport const commentReg = /^\\/\\*(.*?)\\*\\//;\nexport const stringReg = /^\\'(.*?)\\'|^\\\"(.*?)\\\"/;\nexport const stringGreedyReg = /^\\'(.*)\\'|^\\\"(.*)\\\"/;\n// export const regExpReg = /^ExecReg\\((.*)\\)/;\n\nexport const number2bitReg = /^(0b[0|1]{1,})$/;\nexport const number8bitReg = /^(0[0-7]{1,})$/;\nexport const number010bitReg = /^(0\\d*[8-9]{1,}\\d*(\\.\\d+)?)$/; // 0开头的十进制 019 038 078\nexport const number10bitReg = /(^([1-9]\\d*(\\.\\d+)|(\\d*(\\.\\d+)?)))/; // 1-9 或者.开头的十进制\nexport const number16bitReg = /^(0x[0-9a-fA-F]{1,})$/;\nexport const numberEbitReg =  /^((\\d*\\.?\\d*)[e|E]((\\-|\\+)?\\d+))/; // 科学计数法\n\nexport const variableReg = /^((_|$)?[0-9a-zA-Z|$|_]{1,})/;\nexport const operatorReg = new RegExp(`^(${supportOperator.map(r => `(\\\\${/\\b\\w+\\b/.test(r) ? `${r}\\\\s+` : r.split('').join('\\\\')})`).join('|')})`);\nexport const unaryMapReg = new RegExp(`^(${Object.keys(system.unaryOps).filter(item => /\\b\\w+\\b/.test(item)).join('|')})`);\nexport const unarySymbolMapReg = new RegExp(`^(${Object.keys(system.unaryOps).filter(item => !(/\\b\\w+\\b/.test(item))).map(r => `\\\\s*\\\\${r}\\\\s*`).join('|')})`);\nexport const constsMapReg = new RegExp(`^(${Object.keys(system.consts).map(k=>`${k}`).join('|')})`)\n\nexport const execFactoryReg = (reg: RegExp, expr: string, cb: <T>(v: T) => T = (v => v)): string | undefined => {\n  reg.lastIndex = 0;\n  const result = reg.exec(expr);\n  if (result === null || result[0] === '') {\n    return cb(undefined)\n  } else {\n    return cb(result[1])\n  }\n}\n\nexport const isUnaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.unaryOps, value)\nexport const isBinaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.binaryOps, value)\nexport const isTernaryOpeator = ({ value }) => Object.prototype.hasOwnProperty.call(system.ternaryOps, value)","import Ceval from './index';\nimport { TypeTokenStream, TypeToken, TypeInstruction } from './interface';\nimport Instruction, { INSTR_EXPRE, INSTR_FUNCDEF, INSTR_PLAIN, INSTR_VARNAME, INSTR_NAME, INSTR_FUNCALL, INSTR_OBJECT, INSTR_OPERA1, INSTR_MEMBER, INSTR_OPERA2, INSTR_OPERA3, INSTR_ARRAY, INSTR_NUMBER, INSTR_VAR } from './instruction';\nimport { TOKEN_OPERATOR, TOKEN_NAME, TOKEN_SQUARE, TOKEN_PAREN, TOKEN_NUMBER, TOKEN_STRING, TOKEN_COMMA, TOKEN_SEMICOLON, TOKEN_END, TOKEN_CURLY, TOKEN_VAR, TOKEN_FUNC } from './token';\nimport { unarySymbolMapReg, isUnaryOpeator } from './utils/regExp';\nimport { contains } from './utils/index';\n\n/**\n * 解析器\n * @export\n * @class Parser\n */\nexport default class Parser {\n  /**\n   * @desc 当前TOKEN指针\n   */\n  current: TypeToken | null = null;\n\n  /**\n   * @desc 暂存指针\n   */\n  savedCurrent: TypeToken | null = null;\n\n  /**\n   * @desc 下个TOKEN指针对象\n   */\n  nextToken: TypeToken | null = null;\n\n  /**\n   * @desc 暂存next TOKEN\n   */\n  savedNextToken: TypeToken | null = null;\n\n  constructor(public ceval: Ceval, public tokens: TypeTokenStream, exprInstr: TypeInstruction[]) {\n    this.next();\n    \n    this.inspectParseEnd(exprInstr)\n  }\n\n  /**\n   * 检查是否解析完毕\n   */\n  private inspectParseEnd = (exprInstr: TypeInstruction[]) => {\n    const len = this.tokens.expression.length\n    do {\n      this.parseExpression(exprInstr)\n    } while (this.current.index < len && this.nextToken.type !== TOKEN_END) \n  }\n\n  /**\n   * 生成实例解析表达式，简化调用方式\n   */\n  static generatorParser = (parser: Ceval, tokens: TypeTokenStream, exprInstr: TypeInstruction[]): Parser => {\n    return new Parser(parser, tokens, exprInstr)\n  }\n\n  /**\n   * Token指针向下位移\n   */\n  next = (): TypeToken => {\n    this.current = this.nextToken;\n    return (this.nextToken = this.tokens.next())\n  }\n\n  /**\n   * 条件是否命中Token真值\n   */\n  matchToken = (value: undefined | ((value: TypeToken) => boolean) | string | number): boolean => {\n    if (value === undefined) {\n      return true\n    } else if (Array.isArray(value)) {\n      return value.indexOf(this.nextToken.value) !== -1\n    } else if (typeof value === 'function') {\n      return value(this.nextToken)\n    } else if (typeof value === 'string' || typeof value === 'number') {\n      return value === this.nextToken.value\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * 预判是否符合预期，符合&&解析下个token\n   * @param {type} 约定的类型\n   * @param {value} 明确规定的字面值，比如 ] , =\n   * @param {next} 允许next？\n   */\n  accept = (type: string, value?, next = true): boolean => {\n    if (this.nextToken && (this.nextToken.type === type) && this.matchToken(value)) {\n      if (next) this.next()\n      return true\n    }\n    return false\n  }\n\n  /**\n   * accpet + 断言\n   * @param {type} 约定的类型\n   * @param {value} 明确规定的字面值，比如 ] , =\n   */\n  expect = (type: string, value?): never | boolean => {\n    if (!this.accept(type, value)) {\n      const { line, column } = this.tokens.getCoordinates()\n      this.printLog(`> line:${line} column:${column - 1} \"${this.current.value}\"\\nThe next tag should be \"${value}\", But the reality is`, `${this.nextToken.type === TOKEN_END ? 'empty content' : `\"${this.nextToken.value}\"`}`\n        , console.error\n      )\n      throw new Error('Unexpected Tag');\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * 暂存指针，在某些情况下单一的nextToken已经不满足预判情况，例如 typeof(add) || add(1, 2) || 1 + add;\n   */\n  temporarySaved = (): void => {\n    this.savedCurrent = this.current;\n    this.savedNextToken = this.nextToken;\n\n    this.tokens.temporarySaved()\n  }\n\n  /**\n   * 恢复指针\n   */\n  restore = (): void => {\n    this.current = this.savedCurrent;\n    this.nextToken = this.savedNextToken;\n    this.tokens.restore()\n    return void 0;\n  }\n\n  /**\n   * 解析表达式整个句柄\n   * @see 如果只是求参或解析字面量，请从Conditional开始，因为MultipleEvaluation可能会误会语义，e.g.{a:1,b:2}中的“1,b:2”\n   */\n  parseExpression = (instr: TypeInstruction[]): void => {\n    const exprInstr: TypeInstruction[] = []\n    \n    this.parseMultipleEvaluation(exprInstr)\n    exprInstr.forEach(exp => (instr.push(exp)))\n  }\n\n  /**\n   * 解析连续求值 例如 数组字面量 [1, 2, [3, 4, 5]]  (1, 2, 3)\n   */\n  parseMultipleEvaluation = (exprInstr: TypeInstruction[]): void => {\n    this.parseAssignmentExpression(exprInstr)\n    while (this.accept(TOKEN_COMMA, ',')) {\n      this.parseConditionalExpression(exprInstr)\n    }\n  }\n\n  /**\n   * 解析变量赋值表达式 TOKEN_OPERATOR name = 1\n   */\n  parseAssignmentExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseConditionalExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '=')) {\n      let ident: TypeInstruction\n      if(exprInstr[exprInstr.length - 1].type === INSTR_VAR){\n        ident = exprInstr.pop()\n      };\n      const instr: TypeInstruction[] = []\n      this.parseConditionalExpression(instr)\n      exprInstr.push(new Instruction(INSTR_EXPRE, instr));\n      if(ident) {\n        exprInstr.push(ident)\n      } else {\n        exprInstr.push(new Instruction(INSTR_OPERA2, '='))\n      }\n    }\n  }\n\n  /**\n   * 解析三目运算符\n   */\n  parseConditionalExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseOrExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '?')) {\n      const trueBranch = [];\n      const falseBranch = [];\n      this.parseConditionalExpression(trueBranch);\n      this.expect(TOKEN_OPERATOR, ':');\n      this.parseConditionalExpression(falseBranch);\n      exprInstr.push(new Instruction(INSTR_EXPRE, trueBranch));\n      exprInstr.push(new Instruction(INSTR_EXPRE, falseBranch));\n      exprInstr.push(new Instruction(INSTR_OPERA3, '?'));\n    }\n  }\n\n  /**\n   * 解析 ||\n   */\n  parseOrExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseAndExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '||')) {\n      var branch = []\n      this.parseAndExpression(branch)\n      exprInstr.push(new Instruction(INSTR_EXPRE, branch))\n      exprInstr.push(new Instruction(INSTR_OPERA2, '||'))\n    }\n  }\n\n  /**\n   * 解析 &&\n   */\n  parseAndExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseOrExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '&&')) {\n      var branch = []\n      this.parseBitwiseOrExpression(branch)\n      exprInstr.push(new Instruction(INSTR_EXPRE, branch))\n      exprInstr.push(new Instruction(INSTR_OPERA2, '&&'))\n    }\n  }\n\n  /**\n   * 解析 ^ 按位异或\n   */\n  parseBitwiseOrExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseAndExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '^')) {\n      this.parseBitwiseAndExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, '^'))\n    }\n  }\n\n  /**\n   * 解析 & 按位与\n   */\n  parseBitwiseAndExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseEqualExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, '&')) {\n      this.parseBitwiseAndExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, '&'))\n    }\n  }\n\n  /**\n   * 解析判等 ['==', '===', '!=', '!==']\n   */\n  parseEqualExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseCompareExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['==', '===', '!=', '!=='])) {\n      var op = this.current\n      this.parseCompareExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析比较运算符 ['<', '<=', '>=', '>']\n   */\n  parseCompareExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseInOrAtExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['<', '<=', '>=', '>'])) {\n      var op = this.current\n      this.parseInOrAtExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n  * 解析或运算符 ['||', '@'] @待补位\n  */\n  parseInOrAtExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseBitwiseMoveExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, ['in'/** ,\"@\" */])) {\n      var op = this.current\n      this.parseBitwiseMoveExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析按位移 [\">>\", \">>>\", \"<<\"]\n   */\n  parseBitwiseMoveExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseAddOrSubExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\">>\", \">>>\", \"<<\"])) {\n      var op = this.current\n      this.parseAddOrSubExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析加减法 + -\n   */\n  parseAddOrSubExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseMulOrDivExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\"+\", \"-\"])) {\n      var op = this.current\n      this.parseMulOrDivExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析乘除取模 * / %\n   */\n  parseMulOrDivExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseUnaryExpression(exprInstr)\n    while (this.accept(TOKEN_OPERATOR, [\"*\", \"/\", \"%\"])) {\n      var op = this.current\n      this.parseUnaryExpression(exprInstr)\n      exprInstr.push(new Instruction(INSTR_OPERA2, op.value))\n    }\n  }\n\n  /**\n   * 解析一元运算符 [+, ++, +, -, !, ~, cos, tan, typeof]\n   */\n  parseUnaryExpression = (exprInstr: TypeInstruction[]): void => {\n    this.temporarySaved();\n    if (this.accept(TOKEN_OPERATOR, isUnaryOpeator)) {// 内置函数调用\n      if (unarySymbolMapReg.test(this.current.value)) { // +, ++, +, -, !, ~,\n        const op = this.current\n        this.parseUnaryExpression(exprInstr); // 兼容 ++-1\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      } else if (this.accept(TOKEN_PAREN, '(', false)) { // typeof(\n        const op = this.current\n        this.accept(TOKEN_PAREN, '(')\n        this.parseConditionalExpression(exprInstr);\n        this.expect(TOKEN_PAREN, ')')\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      } else if (\n        [TOKEN_COMMA, TOKEN_SEMICOLON, TOKEN_END].indexOf(this.nextToken.type) !== -1 || // typeof, typeof; typeof\n        (this.nextToken.type === TOKEN_PAREN && this.nextToken.value === ')') // typeof)\n      ) {\n        this.restore();\n        this.parseField(exprInstr);\n      } else { // 需要支持typeof 1 ; typeof typeof 1 === typeof(typeof(1)) === typeof(typeof 1);\n        const op = this.current\n        this.parseUnaryExpression(exprInstr) // 外置函数 || 内声明函数\n        exprInstr.push(new Instruction(INSTR_OPERA1, op.value))\n      }\n    } else {\n      this.parseOuterFunctionCallExpression(exprInstr) // 外置函数 || 内声明函数\n    }\n  }\n\n  /**\n   * 外置函数调用\n   */\n  parseOuterFunctionCallExpression = (exprInstr: TypeInstruction[]) => {\n    this.parseMemberAccessExpression(exprInstr)\n    if (this.current.type === TOKEN_NAME && this.accept(TOKEN_PAREN, '(', false)) {\n      this.parseArguments(exprInstr)\n    }\n  }\n\n  /**\n   * 解析内置函数调用\n   */\n  // parsePersetFuncCallExpression = (exprInstr: TypeInstruction[]): void => {\n  //     this.parseMemberAccessExpression(exprInstr); // a.b()\n  //     this.parseArguments(exprInstr)\n  // }\n\n  /**\n   * 解析调用函数的实参\n   */\n  parseArguments = (exprInstr: TypeInstruction[]): void => {\n    while (this.accept(TOKEN_PAREN, '(')) {\n      if (this.accept(TOKEN_PAREN, ')')) {\n        // 立即调用\n        exprInstr.push(new Instruction(INSTR_FUNCALL, 0)) // 参数长度 \n      } else {\n        let count = 0\n        while (!this.accept(TOKEN_PAREN, ')')) {\n          do {\n            this.parseConditionalExpression(exprInstr);\n            count++;\n          } while (this.accept(TOKEN_COMMA))\n        }\n        exprInstr.push(new Instruction(INSTR_FUNCALL, count))\n      }\n    }\n  }\n\n  /**\n   * 解析成员访问符 . []\n   */\n  parseMemberAccessExpression = (exprInstr: TypeInstruction[]): void => {\n    this.parseField(exprInstr);\n    const refPath = [];\n    const currentItem = exprInstr[exprInstr.length - 1];\n    if(currentItem && currentItem.type === INSTR_NAME) {\n      refPath.push(currentItem.value) // 尝试最后一个是否是NAME变量\n    }\n    while (\n      this.accept(TOKEN_OPERATOR, '.') ||\n      (contains([TOKEN_SQUARE, TOKEN_NAME], this.current.type) && this.accept(TOKEN_SQUARE, '['))) {\n        \n      if (!this.ceval.getOptions().allowMemberAccess) {\n        throw new Error(`options \"allowMemberAccess\": You have disabled member access and cannot use syntax such as \"a.b\" \"a['b']\"`)\n      }\n      if (this.current.value === '.') {\n        this.expect(TOKEN_NAME); // a.name ✔️  a.1×\n        refPath.push(new Instruction(INSTR_PLAIN, this.current.value))\n      } else if (this.current.value === '[' && (this.accept(TOKEN_NAME) || this.accept(TOKEN_NUMBER) || this.accept(TOKEN_STRING))) {\n        refPath.push(new Instruction(this.current.type === TOKEN_NAME ? INSTR_NAME : INSTR_PLAIN, this.current.value))\n        this.expect(TOKEN_SQUARE, ']')\n      }\n    }\n    if(refPath.length > 1) {\n      exprInstr.pop(); // 拿到全部引用\n      exprInstr.push(new Instruction(INSTR_MEMBER, refPath))\n    }\n  }\n\n\n  /**\n   * 解析字面值、字段值 number||string||operator(typeof cos tan)||[1,2,3]|| {a:1,b:{}} || (expression) || function abs() {}\n   */\n  parseField = (exprInstr: TypeInstruction[]): void => {\n    if (this.accept(TOKEN_OPERATOR, isUnaryOpeator)) {\n      // 内置前缀运算符 cos tan - +\n      exprInstr.push(new Instruction(INSTR_OPERA1, this.current.value));\n    } else if (this.accept(TOKEN_NAME)) {\n      // 变量名称\n      if(this.accept(TOKEN_OPERATOR, '=', false)) {// 赋值操作，避免转成TOKEN_NAME去取值了。\n        exprInstr.push(new Instruction(INSTR_VARNAME, this.current.value));\n      } else {\n        exprInstr.push(new Instruction(INSTR_NAME, this.current.value));\n      }\n    } else if (this.accept(TOKEN_NUMBER)) {\n      // 数字类型\n      exprInstr.push(new Instruction(INSTR_NUMBER, this.current.value));\n    } else if (this.accept(TOKEN_STRING)) {\n      // 字符串类型 \\\"name\\\"\n      exprInstr.push(new Instruction(INSTR_PLAIN, this.current.value));\n    } else if (this.accept(TOKEN_PAREN, '(')) {\n      // 圆括号，调用 或 表达式(a=1)\n      this.parseExpression(exprInstr);\n      this.expect(TOKEN_PAREN, ')');\n    } else if (this.accept(TOKEN_SQUARE, '[')) {\n      //  数组字面量\n      this.parseArrayLiteralDeclaration(exprInstr)\n    } else if (this.accept(TOKEN_CURLY, '{', false)) {\n      // Object字面量声明\n      this.parseObjectLiteralDeclaration(exprInstr)\n    } else if (this.accept(TOKEN_VAR, ['const', 'var', 'let'])) {\n      // 赋值表达式 需要收集ident 和 variableName 避免variableName识别成varName 引发error\n      const identifier = this.current\n      this.expect(TOKEN_NAME)\n      exprInstr.push(new Instruction(INSTR_VARNAME, this.current.value));\n      exprInstr.push(new Instruction(INSTR_VAR, identifier.value))\n    } else if (this.accept(TOKEN_FUNC, undefined, false)) {\n      this.parseFunctionDefinedDeclaration(exprInstr);\n    } else if (this.accept(TOKEN_SEMICOLON)) {\n      // empty, fault tolerant \n    } else {\n      throw new Error('unexpected ' + this.nextToken);\n    }\n  }\n\n  /**\n   * 解析对象字面量 { a: 1, b: 2, c: {}}\n   */\n  parseArrayLiteralDeclaration = (exprInstr: TypeInstruction[]) => {\n    // Array字面量声明 TODO: 需要和 obj['a'] 做区分\n    const instr = []\n    if (this.accept(TOKEN_SQUARE, ']')) { // []\n      exprInstr.push(new Instruction(INSTR_ARRAY, instr))\n      return\n    }\n    this.parseExpression(instr)\n    this.expect(TOKEN_SQUARE, ']')\n    exprInstr.push(new Instruction(INSTR_ARRAY, instr))\n  }\n\n  /**\n   * 解析对象字面量 { a: 1, b: 2, c: {}}\n   */\n  parseObjectLiteralDeclaration = (exprInstr: TypeInstruction[]) => {\n    while (this.accept(TOKEN_CURLY, '{')) {\n      const instr = {}\n      if (this.accept(TOKEN_CURLY, '}')) { // {}\n        exprInstr.push(new Instruction(INSTR_OBJECT, instr))\n        return\n      }\n      while (this.accept(TOKEN_NAME) || this.accept(TOKEN_NUMBER) || this.accept(TOKEN_STRING)) {\n        const key = this.current.value\n        this.expect(TOKEN_OPERATOR, ':');\n        instr[key] = [];\n        if (this.accept(TOKEN_CURLY, '{', false)) {\n          this.parseObjectLiteralDeclaration(instr[key])\n        } else {\n          this.parseConditionalExpression(instr[key]);\n        }\n        this.accept(TOKEN_COMMA, ',');\n      }\n      this.expect(TOKEN_CURLY, '}');\n      this.accept(TOKEN_SEMICOLON, ';')\n      exprInstr.push(new Instruction(INSTR_OBJECT, instr))\n    }\n  }\n\n  /**\n   * 解析函数声明\n   */\n  parseFunctionDefinedDeclaration = (expreInstr: TypeInstruction[]) => {\n    while (this.accept(TOKEN_FUNC)) {\n      if (this.accept(TOKEN_NAME)) { // function fn(){}\n        const funcName = this.current.value;\n        const instr = []; // 参数 与 函数体\n        if (this.accept(TOKEN_PAREN, '(')) {\n          do {\n            this.parseField(instr); // TODO fn(a=1) 待兼容\n          } while (this.accept(TOKEN_COMMA))\n          this.expect(TOKEN_PAREN, ')')\n        }\n        this.parseFunctionBodyExpression(instr)\n        expreInstr.push(new Instruction(INSTR_FUNCDEF, instr))\n        expreInstr.push(new Instruction(INSTR_FUNCDEF, funcName))\n      }\n    }\n  }\n\n  /**\n   * 解析函数体, 花括号 { }, 应该视作一个新的作用域. // TODO: 可作为单独作用域体\n   */\n  parseFunctionBodyExpression = (exprInstr: TypeInstruction[]) => {\n    if (this.accept(TOKEN_CURLY, '{')) {\n      const instr = [];\n      do {\n        this.parseExpression(instr)\n      } while (this.accept(TOKEN_SEMICOLON, ';') && !this.accept(TOKEN_CURLY, '}', false))\n      if(this.current.type !== TOKEN_SEMICOLON) {\n        throw new SyntaxError(`Function parse error: Function body each line must end with semicolon ';'`)\n      }\n      this.expect(TOKEN_CURLY, '}')\n      this.accept(TOKEN_SEMICOLON, ';')\n      exprInstr.push(new Instruction(INSTR_EXPRE, instr))\n    }\n  }\n\n  /**\n   * 增加提示\n   */\n  printLog = (msg: string, tip: string, c: Console[\"log\" | \"error\" | \"warn\"] = console.log) => {\n    c(`${msg} %c${tip}`, `margin: 0 .5em;text-decoration-line: underline;text-decoration-color: red;text-decoration-style: wavy;line-height: 2em;color: red;`)\n  }\n}","/** @desc javascript保留字 */\nexport const jsWord = {\n  \"abstract\": false,\n  \"arguments\": false,\n  \"boolean\": false,\n  \"break\": false,\n  \"byte\": false,\n  \"case\": false,\n  \"catch\": false,\n  \"char\": false,\n  \"class\": false,\n  \"const\": false,\n  \"continue\": false,\n  \"debugger\": false,\n  \"default\": false,\n  \"delete\": false,\n  \"do\": false,\n  \"double\": false,\n  \"else\": false,\n  \"enum\": false,\n  \"eval\": false,\n  \"export\": false,\n  \"extends\": false,\n  \"final\": false,\n  \"finally\": false,\n  \"float\": false,\n  \"for\": false,\n  \"function\": false,\n  \"goto\": false,\n  \"if\": false,\n  \"implements\": false,\n  \"import\": false,\n  \"in\": true,\n  \"instanceof\": false,\n  \"int\": false,\n  \"interface\": false,\n  \"let\": false,\n  \"long\": false,\n  \"native\": false,\n  \"new\": false,\n  \"null\": false,\n  \"package\": false,\n  \"private\": false,\n  \"protected\": false,\n  \"public\": false,\n  \"return\": true,\n  \"short\": false,\n  \"static\": false,\n  \"super\": false,\n  \"switch\": false,\n  \"synchronized\": false,\n  \"this\": false,\n  \"throw\": false,\n  \"throws\": false,\n  \"transient\": false,\n  \"try\": false,\n  \"typeof\": false,\n  \"var\": false,\n  \"void\": false,\n  \"volatile\": false,\n  \"while\": false,\n  \"with\": false,\n  \"yield\": false\n}\n\n/** @desc JavaScript属性方法保留字 */\nexport const jsAttr = {\n  \"Array\": false, \n  \"Date\": false, \n  \"eval\": false, \n  \"function\": false, \n  \"hasOwnProperty\": false,\n  \"Infinity\": false, \n  \"isFinite\": false, \n  \"isNaN\": false, \n  \"isPrototypeOf\": false, \n  \"length\": false,\n  \"Math\": false, \n  \"NaN\": true, \n  \"name\": false, \n  \"Number\": false, \n  \"Object\": false,\n  \"prototype\": false, \n  \"String\": false, \n  \"toString\": false, \n  \"undefined\": false, \n  \"valueOf\": false, \n}\n\n/** @desc window保留字 */\nexport const windowWord = {\n  \"alert\": false, \n  \"all\": false, \n  \"anchor\": false, \n  \"anchors\": false, \n  \"area\": false,\n  \"assign\": false, \n  \"blur\": false, \n  \"button\": false, \n  \"checkbox\": false, \n  \"clearInterval\": false,\n  \"clearTimeout\": false, \n  \"clientInformation\": false, \n  \"close\": false, \n  \"closed\": false, \n  \"confirm\": false,\n  \"constructor\": false, \n  \"crypto\": false, \n  \"decodeURI\": false, \n  \"decodeURIComponent\": false, \n  \"defaultStatus\": false,\n  \"document\": false, \n  \"element\": false, \n  \"elements\": false, \n  \"embed\": false, \n  \"embeds\": false,\n  \"encodeURI\": false, \n  \"encodeURIComponent\": false, \n  \"escape\": false, \n  \"event\": false, \n  \"fileUpload\": false,\n  \"focus\": false, \n  \"form\": false, \n  \"forms\": false, \n  \"frame\": false, \n  \"innerHeight\": false,\n  \"innerWidth\": false, \n  \"layer\": false, \n  \"layers\": false, \n  \"link\": false, \n  \"location\": false,\n  \"mimeTypes\": false, \n  \"navigate\": false, \n  \"navigator\": false, \n  \"frames\": false, \n  \"frameRate\": false,\n  \"hidden\": false, \n  \"history\": false, \n  \"image\": false, \n  \"images\": false, \n  \"offscreenBuffering\": false,\n  \"open\": false, \n  \"opener\": false, \n  \"option\": false, \n  \"outerHeight\": false, \n  \"outerWidth\": false,\n  \"packages\": false, \n  \"pageXOffset\": false, \n  \"pageYOffset\": false, \n  \"parent\": false, \n  \"parseFloat\": false,\n  \"parseInt\": false, \n  \"password\": false, \n  \"pkcs11\": false, \n  \"plugin\": false, \n  \"prompt\": false,\n  \"propertyIsEnum\": false, \n  \"radio\": false, \n  \"reset\": false, \n  \"screenX\": false, \n  \"screenY\": false,\n  \"scroll\": false, \n  \"secure\": false, \n  \"select\": false, \n  \"self\": false, \n  \"setInterval\": false,\n  \"setTimeout\": false, \n  \"status\": false, \n  \"submit\": false, \n  \"taint\": false, \n  \"text\": false,\n  \"textarea\": false, \n  \"top\": false, \n  \"unescape\": false, \n  \"untaint\": false, \n  \"window\": false\n}","import Token, { TOKEN_END, TOKEN_STRING, TOKEN_COMMA, TOKEN_FUNC, TOKEN_CURLY, TOKEN_PAREN, TOKEN_SEMICOLON, TOKEN_VAR, TOKEN_NUMBER, TOKEN_NAME, TOKEN_OPERATOR, TOKEN_SQUARE } from './token';\nimport { TypeToken, TypeCeval } from './interface';\nimport { whitespaceReg, commentReg, stringReg, constsMapReg, number2bitReg, number8bitReg, number10bitReg, number16bitReg, variableReg, operatorReg, unaryMapReg, booleanReg, execFactoryReg, number010bitReg, stringGreedyReg, numberEbitReg } from './utils/regExp';\nimport { jsWord, jsAttr } from './utils/reservedWord';\nimport { contains, isPalindrome, filterUndefine } from './utils/index';\n\n/**\n * 语法解析\n * @class TokenStream\n */\nexport default class TokenStream {\n  // 当前指针下标\n  pos = 0;\n\n  // 当前解析character\n  current: null | TypeToken = null;\n\n  // 暂存指针\n  savedPosition = 0;\n\n  // 暂存解析character，在某些情况下做预判比如, cos是函数，cos() || map(cos) “cos)” 可能被函数parser判定为语法错误\n  savedCurrent: null | TypeToken = null;\n\n  // eslint-disable-next-line\n  constructor(public ceval: TypeCeval, public expression: string) {}\n\n  /**\n   * @desc 获取nextToken，适用语法前置校验\n   * @memberof TokenStream\n   */\n  checkNextAccessGrammar = (): TypeToken => {\n    this.temporarySaved();\n    const next = this.next();\n    this.restore();\n    return next\n  }\n\n  /**\n   * @desc 某些情况下做正则优化，比如 operator 至多3位，所以截取3位再匹配\n   * @param len 获取的长度\n   * @param offset 位移\n   * @see charAt与substr性能对比 https://jsperf.com/substr-or-charat\n   * @memberof TokenStream\n   */\n  getSomeCode = (len = 1, offset = 0): string => {\n    const start = offset + this.pos\n    const { length } = this.expression;\n    // debugger\n    return this.expression.substr(start, (start + len) > length ? length - start : len)\n  }\n\n  /**\n   * @desc 获取首个单词\n   * @memberof TokenStream\n   */\n  getFirstWord = (): string => {\n    const result = this.expression.substr(this.pos).match(/\\b\\w*\\b/)\n    return result ? result[0] : ''\n  }\n\n  /**\n   * 创建新的fieldType实例\n   * @memberof TokenStream\n   */\n  newToken = (type: string, value: number | string, pos?: number): TypeToken => {\n    return new Token(type, value, pos != null ? pos : this.pos);\n  }\n\n  /**\n   * 解析下一个 field\n   * @memberof TokenStream\n   */\n  next = (): TypeToken => {\n    if (!this.expression.length) {\n      return this.newToken(TOKEN_NAME, \"undefined\")\n    }\n    if (this.pos >= this.expression.length) {\n      return this.newToken(TOKEN_END, 'END');\n    }\n\n    if (this.isWhiteSpace() || this.isComment()) {\n      return this.next()\n    } else if (\n      this.isNumber() ||\n      this.isString() ||\n      this.isBoolean() ||\n      this.isParenthesis() ||\n      this.isComma() ||\n      this.isOperator() ||\n      this.isSemicolon() ||\n      this.isConst() ||\n      this.isVariable() ||\n      this.isFunctionDefined() ||\n      this.isName()\n    ) {\n      return this.current\n    } else {\n      this.parseError(`unknown character: ${this.expression.charAt(this.pos)}`, SyntaxError)\n    }\n  }\n\n  temporarySaved = (): void => {\n    this.savedPosition = this.pos;\n    this.savedCurrent = this.current;\n  }\n\n  restore = (): void => {\n    this.pos = this.savedPosition;\n    this.current = this.savedCurrent\n  }\n\n  /**\n   * 过滤空格 \\t \\r \\n\n   * @memberof TokenStream\n   */\n  isWhiteSpace = (): boolean => {\n    const matchWS = whitespaceReg.exec(this.getSomeCode())\n    while (matchWS && matchWS[1]) {\n      this.pos++\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 过滤注释 /*  *\\/\n   * @memberof TokenStream\n   */\n  isComment = (): boolean => {\n    const prefixCm = this.getSomeCode(2);\n    let matchResult: string | undefined\n    if (prefixCm === '/*') {\n      matchResult = execFactoryReg(commentReg, this.getSomeCode(Infinity))\n    } else if(prefixCm === '//') { // comment break line\n      matchResult = execFactoryReg(/^(\\/\\/.*\\n?)/, this.getSomeCode(Infinity));\n    }\n\n    if (matchResult) {\n      this.pos += matchResult.length +(prefixCm === '/*'? (2 + 2):0); // /*matchResult*/\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 过滤空格 \\t \\r \\n\n   * @memberof TokenStream\n   */\n  isBoolean = (): boolean => {\n    const matchWS = booleanReg.exec(this.getSomeCode())\n    while (matchWS && matchWS[1]) {\n      this.pos++\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 申明变量 TODO:support\n   * @memberof TokenStream\n   */\n  isVariable = (): boolean => {\n    const word = this.getFirstWord()\n    if (contains(['const', 'var', 'let'], word)) {\n      this.pos += word.length;\n      this.current = this.newToken(TOKEN_VAR, word)\n      const nextToken = this.checkNextAccessGrammar()\n\n      if (nextToken.type !== TOKEN_NAME) {\n        throw new Error(`${word} ${nextToken.value} : This syntax Not as expected, should be \"${TOKEN_NAME}\", but is \"${nextToken}\"`)\n      } else if(contains(this.ceval.consts, nextToken.value)){\n        throw new SyntaxError(`SyntaxError:  Unexpected token '${nextToken.value}', it has been stated in consts.`)\n      }\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 数字 \n   * @see 说明 需要考虑到 2进制0b10100 === 8进制024 === 10进制20 === 16进制0x14 === 10e0 === 20.000\n   * @memberof TokenStream\n   */\n  isNumber = (): boolean => {\n    const first = this.getSomeCode()\n    let number: string | undefined\n    let bit: number\n    const expr = this.getSomeCode(this.expression.length - this.pos)\n\n    if ((/\\d|\\./.test(first) === false) || (first === '.' && /\\.\\d/.test(this.getSomeCode(2)) === false)) return false\n\n    const [n] = expr.match(/^(0(x|b)+[0-9a-zA-Z]{1,})|(^0?\\d*(\\.\\d+)?)/); // 019 可能会被8进制拦截掉01， 所以必须要做^$\n    number10bitReg.lastIndex = 0;\n    if (first === '0' && n.length > 1 && !(/^0\\.\\d/.test(n))) { // 0.x 不是进制数\n      if (contains(['b', 'x'], this.getSomeCode(1, 1)) && this.getSomeCode(1, n.length) === '.') {\n        // 0b0101.1 0xaf.1 ❌\n        // 099.1 属于十进制 ✅\n        this.parseError(`number '${n}' cannot is a floating point number, but actual is: '${n}${this.getSomeCode(3, n.length)}'`, SyntaxError)\n        return false\n      }\n\n      if (number2bitReg.test(n)) {\n        // 2进制\n        // @see 0b01 0b1110\n        number = execFactoryReg(number2bitReg, n)\n        bit = number === undefined ? undefined : 2\n      } else if (number8bitReg.test(n)) {\n        // 8进制\n        // @see 012 || 077 ✅ \b\n        // @warn 080 || 079 ❌都是十进制  并非8进制\n        number = execFactoryReg(number8bitReg, n)\n        bit = number === undefined ? undefined : 8\n      } else if (number16bitReg.test(n)) {\n        // 16进制 \n        // @see 0xadf\n        number = execFactoryReg(number16bitReg, n)\n        bit = number === undefined ? undefined : 16\n      } else if (number010bitReg.test(n)) {\n        // 0开头十进制 \n        // @see 079 || 080  ✅\n        // @warn 03.1 || 00.1 || 00.  ❌ \n        number = execFactoryReg(number010bitReg, n)\n        bit = number === undefined ? undefined : 10\n      } else {\n        this.parseError('number bitbase parser error', SyntaxError)\n        return false\n      }\n      this.pos += number.length\n      if (number !== undefined && !this.ceval.getOptions().endableBitNumber) { // 给出准确的warning \n        throw new Error(`options \"endableBitNumber\": You have disabled bitbase number parsing, Not allowed ${number}`)\n      }\n    } else if(numberEbitReg.test(expr)) { // 科学计数法\n      numberEbitReg.lastIndex = 0;\n      const [, match, base, times] = numberEbitReg.exec(expr);\n      this.pos += (match.length || (base.length + times.length + 1));\n      number = match || (Number(base) * Math.pow(10, Number(times))).toString()\n      bit = 10;\n    }else if (number10bitReg.test(expr)) { // 十进制\n      // 100 || 100.1 || 0.1 || .100 || .0  ✅ \n      // parseFloat是支持 0100.1 的。\n      number = execFactoryReg(number10bitReg, expr)\n      bit = number === undefined ? undefined : 10\n      this.pos += number.length\n    } else {\n      return false\n    }\n\n    if (bit === 10) {\n      this.current = this.newToken(TOKEN_NUMBER, parseFloat(number))\n    } else {\n      this.current = this.newToken(TOKEN_NUMBER, parseInt(number.replace('0b', '').replace('0x', ''), bit))\n    }\n    return true\n  }\n\n  /**\n   * 字符串\n   * @see '' \\'\\' \\\"\\\" \\\"\\'\\'\\\"\n   * @memberof TokenStream\n   */\n  isString = (): boolean => {\n    const first = this.getSomeCode()\n    const expr = this.getSomeCode(Infinity)\n    let matchString: RegExpExecArray | undefined\n    let strContent: string | undefined\n    if (first === '\\\"' || first === '\\'') {\n      stringGreedyReg.lastIndex = 0;\n        // 一种情况是需要贪婪匹配 \\'\\'a\\'\\', 判断是否需要贪婪匹配\n      matchString = stringGreedyReg.exec(expr)\n      strContent = filterUndefine(matchString[1], matchString[2])\n      if (!isPalindrome(strContent)) {\n        // 不属于回文字符串则需要重新做惰性匹配\n        // 另一种则需要惰性 \"'a', 'b'\" => \"a\"\n        stringReg.lastIndex = 0;\n        matchString = stringReg.exec(expr);\n        strContent = filterUndefine(matchString[1], matchString[2])\n      }\n\n      if (strContent !== undefined) {\n        this.current = this.newToken(TOKEN_STRING, strContent, this.pos)\n        this.pos += (strContent.length + first.length * 2); // \"\" 是没有长度的，会导致Token指针一直处于 \"\" \n        return true\n      }\n    }\n\n    return false\n  }\n\n  isFunctionDefined = (): boolean => {\n    const word = this.getFirstWord();\n    if(word === 'function') {\n      // TODO: 初期只支持 第一种, 同时支持 function fn() {} || const a = () => {} || const b = function(){}\n      this.current = this.newToken(TOKEN_FUNC, undefined);\n      this.pos+=word.length\n      const nextToken = this.checkNextAccessGrammar(); \n      if(nextToken.type !== TOKEN_NAME) {\n        this.parseError('function definition should have function name')\n        return false\n      }\n      return true;\n    }\n    return false\n  }\n  \n  /**\n   * 变量，可能是名称\n   * @see 遵循变量申明规范 可以以 $_ 开头，其他可以是 $_数字字母 ，排除保留字\n   * @memberof TokenStream\n   */\n  isName = (): boolean => {\n    const first = this.getSomeCode()\n    let result\n    if (first === '_' || first === '$' || /^[a-zA-Z]/.test(first)) {\n      variableReg.lastIndex = 0\n      result = variableReg.exec(this.getSomeCode(Infinity))\n    }\n\n    if (result === undefined || result === null || typeof result[1] !== \"string\") {\n      return false\n    }\n\n    [, result] = result;\n\n    if (jsWord[result] === false) {\n      // 检测到保留字\n      this.parseError(`parser an reserved word: ${result}`)\n      return false\n    }\n\n    if (jsAttr[result] === false) {\n      // 检测到window属性 TODO: 应该命中 window.xxx\n      this.parseError(`parser an window native attributes or methods: ${result}`)\n      return false\n    }\n\n    this.pos += result.length\n    this.current = this.newToken(TOKEN_NAME, result)\n    return true\n  }\n\n  /**\n   * 内置常量\n   * @see const 例如 true false PI undefined null\n   * @memberof TokenStream\n   */\n  isConst = (): boolean => {\n    constsMapReg.lastIndex = 0;\n    const result = constsMapReg.exec(this.getSomeCode(Infinity))\n\n    if (result && result[1]) {\n      this.current = this.newToken(TOKEN_NAME, result[1])\n      this.pos += result[1].length;\n      const constKey = this.checkNextAccessGrammar();\n      // 检查是否是const常量赋值\n      if(constKey.type === TOKEN_OPERATOR && constKey.value === '=') {\n        this.parseError(`parser error: consts of ${this.current.value} can not assignment;`, SyntaxError)\n      }\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * 分号\n   * @see ;\n   * @memberof TokenStream\n   */\n  isSemicolon = (): boolean => {\n    var first = this.getSomeCode();\n    if (first === ';') {\n      this.current = this.newToken(TOKEN_SEMICOLON, ';');\n      this.pos++;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * 逗号,\n   * @see ,\n   * @memberof TokenStream\n   */\n  isComma = (): boolean => {\n    var first = this.getSomeCode();\n    if (first === ',') {\n      this.current = this.newToken(TOKEN_COMMA, ',');\n      this.pos++;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * 圆、方括号\n   * @see ;\n   * @memberof TokenStream\n   */\n  isParenthesis = (): boolean => {\n    var first = this.getSomeCode();\n    if (contains(['(', ')'], first)) {\n      this.current = this.newToken(TOKEN_PAREN, first);\n    } else if (contains(['[', ']'], first)) {\n      this.current = this.newToken(TOKEN_SQUARE, first);\n    } else if (contains(['{', '}'], first)) {\n      this.current = this.newToken(TOKEN_CURLY, first);\n    } else {\n      return false\n    }\n    this.pos++;\n    return true;\n  };\n\n  /**\n   * 判断是否操作符 \n   * @see 操作符 + - * / || % ^ ? : . > < = >= <= | == === != !== in\n   * @memberof TokenStream\n   */\n  isOperator = (): boolean => {\n    const str = this.getSomeCode(Infinity);\n    let result: string | undefined\n    if (operatorReg.test(str)) {\n      result = execFactoryReg(operatorReg, str)\n    } else if (unaryMapReg.test(str)) {\n      result = execFactoryReg(unaryMapReg, str)\n    }\n    \n    if (!result) return false\n\n    if(this.ceval.getOptions().endableOperators === false) {\n      throw new Error(`options \"endableOperators\": You disabled the operator, Therefore, \"${result}\" it can not be used`)\n    }\n    result = result.replace(/\\s/g, '')\n    this.pos += result.length\n    this.current = this.newToken(TOKEN_OPERATOR, result)\n    return true\n  }\n\n  /**\n   * 获取当前character定位\n   * @memberof TokenStream\n   */\n  getCoordinates = (): { line: number, column: number } => {\n    let line = 0;\n    let column = 0;\n    let index = -1;\n    \n    do {\n      line++;\n      column = this.pos - index;\n      index += 1\n      index += this.expression.substr(index).indexOf('\\n'); // 从每一行第一位开始寻找下一个换行符\n    } while (index >= 0 && index < this.pos && line < this.pos)\n    return {\n      line,\n      column\n    };\n  };\n\n  /**\n   * 解析出错\n   * @memberof TokenStream\n   */\n  parseError = (msg: string, ErrorType: ErrorConstructor | SyntaxErrorConstructor | TypeErrorConstructor = Error): never => {\n    var coords = this.getCoordinates();\n    throw new ErrorType('parse error [' + coords.line + ':' + coords.column + '] => ' + msg);\n  };\n\n}","import Instruction, { INSTR_EXPRE, INSTR_FUNCDEF, INSTR_EXECUTBODY, INSTR_VARNAME, INSTR_NAME, INSTR_OBJECT, INSTR_ARRAY, INSTR_FUNCALL, INSTR_MEMBER, INSTR_NUMBER, INSTR_VAR, INSTR_OPERA2, INSTR_PLAIN, INSTR_OPERA3, INSTR_OPERA1 } from './instruction';\nimport Ceval from './index';\nimport { hasAttribute, mapToObject, merge, someCondition, getReference, Reference } from './utils/index';\n\n/**\n * 运算\n * @export calculation\n * @param {Instruction[]} tokens    TokenQueue\n * @param {object} [values={}]      数据池\n * @param {Ceval} ceval             instance of eval\n * @param {boolean} [statis=false]  true全量返回 默认false\n * @param {object} [scope={}]       作用域\n * @returns result or result[]\n */\nexport default function calculation(tokens: Instruction<any>[], values = Object.create(null), ceval: Ceval, statis = false, scope = Object.create(null)) {\n  // if (window && window.name) {\n  //  console.group('calclation Dev')\n  //   console.log('tokens: ', tokens);\n  //   console.log('values', values)\n  //   console.log('scope', scope)\n  //  console.groupEnd()\n  // }\n  const options = ceval.getOptions();\n  const { unaryOps, binaryOps, ternaryOps } = ceval\n  const stack = [];\n  const { length } = tokens;\n  let n1, n2, n3;\n  let fn: undefined | Function | Instruction<CustomFunc>\n  for (let i = 0; i < length; i++) {\n    const item = tokens[i];\n    const { type, value } = item || {};\n\n    if (!type) {\n      stack.push(item)\n      continue\n    }\n    switch(type) {\n      case INSTR_NUMBER: \n      case INSTR_PLAIN:\n      case INSTR_VARNAME: {\n        stack.push(value);\n        break\n      }\n      case INSTR_NAME: {\n        // 变量名称，范围作用域有functions consts values _scope 后者优先\n        if (hasAttribute(scope, value)) {\n          // scope,作用域\n          stack.push(scope[value])\n        } else if (hasAttribute(values, value)) {\n          // customVal\n          stack.push(values[value])\n        } else if (hasAttribute(ceval.consts, value)) {\n          // 常量\n          stack.push(ceval.consts[value])\n        } else if(hasAttribute(ceval.functions, value)) {\n          // 内置函数\n          stack.push(ceval.functions[value])\n        } else {\n          throw new Error(`${value} is not defined in values or consts`)\n        }\n        break\n      }\n      case INSTR_OPERA1: {\n        if(stack.length === 0) break;\n        // 一元运算，需要一个操作数\n        [n1] = stack.splice(-1, 1);\n        fn = specifyAttr<Function>(value, [values, unaryOps], options.allowOperatorsCovered)\n        \n        stack.push(fn(n1));\n        // 当操作符是return 时，终止该运算循环\n        if(value === 'return') {\n          i = length\n        }\n        break\n      }\n      case INSTR_OPERA2: { // 二元运算，需要有两个操作数\n        if(stack.length < 2) break;\n        [n1, n2] = stack.splice(-2, 2)\n          fn = specifyAttr<Function>(value, [values, binaryOps], options.allowOperatorsCovered)\n        if (value === '&&') { // 1&&0&&3可能是连续的\n          stack.push(fn(n1, calculation([n2], values, ceval, statis, scope), false)); // true && true && false\n        } else if (value === '=') {\n          // 写操作分为属性赋值和引用赋值\n          if(n1 instanceof Reference) { // left hide 为引用\n            n1.setValue(n2);\n            n1.destory();\n          } else {\n            someCondition(hasAttribute(scope, n1), hasAttribute(values, n1), `${n1} is not define in values or current scope, if you are declaring a new variable, please add var, const or let operator`)\n            fn(n1, n2, hasAttribute(scope, n1) ? scope : values)\n          // 如果当前作用域含有该属性，作用域优先\n          }\n        } else {\n          stack.push(fn(n1, (typeof n2 === 'string' || typeof n2 === 'number') ? n2: calculation([n2], values, ceval, statis, scope), options));\n        }\n        break\n      }\n      case INSTR_OPERA3: { // 三元运算，需要有三个操作数\n        if(stack.length < 3) break;\n        [n1, n2, n3] = stack.splice(-3, 3)\n        fn = specifyAttr<Function>(value, [values, ternaryOps], options.allowOperatorsCovered)\n        stack.push(fn(n1, n2, n3));\n        break\n      }\n      case INSTR_EXPRE: { // 表达式\n        stack.push(calculation(item.value, values, ceval, statis, scope))\n        break;\n      }\n      case INSTR_MEMBER: { // 成员访问\n        // 有可能是读，也有可能是写；\n        const nextItem = tokens[i+2]; // 解析顺序 INSTR_MEMBER => INSTR_EXPRE => INSTR_OP2\n        const keys = calculation(value, values, ceval, true, scope)\n        const ref = getReference(keys, scope, values)\n        \n        if(nextItem && nextItem.type === INSTR_OPERA2 && nextItem.value === '=') {\n          // 写操作, JavaScript是拿不到引用的，push到stack，等待引用赋值\n          stack.push(ref)\n        } else {\n          stack.push(ref.getValue())\n          ref.destory();\n        }\n        \n        break\n      }\n      case INSTR_ARRAY: { // 数组字面量\n        stack.push(calculation(value, values, ceval, true, scope))\n        break\n      }\n      case INSTR_OBJECT: { // 对象字面量\n        const instr = Object.create(null)\n        Object.keys(value).forEach(key => {\n          instr[key] = calculation(value[key], values, ceval, statis,scope)\n        })\n        stack.push(instr)\n        break\n      }\n      case INSTR_VAR: { // 赋值语句\n        [n1, n2] = stack.splice(-2, 2)\n        switch (value) {\n          case 'let':\n          case 'const': {\n            // let const的行为待定义, let 和 const 应该挂载到作用域上，而var 可以赋给 values \n            // TODO: 需要判定assgin给scope还是values\n            if (hasAttribute(scope, n1)) {\n              console.warn(`${n1} already statement in consts or scope`)\n            }\n            scope[n1] = n2;\n            break\n          }\n          case 'var': {\n            values[n1] = n2; \n            break\n          }\n          default: {\n            console.warn('Unexpected statement identifier')\n            break;\n          }\n        }\n        break\n      }\n      case INSTR_FUNCALL: { // 自声明函数调用，区分是外部函数还是内声明函数\n        const args = stack.splice(-value, value);\n        fn = stack.pop();\n        // if(args.length !== value) {} // TODO: 参数不够的情况 warning\n        if (typeof fn === 'function') {\n          // 外置函数，即在consts内声明的\n          stack.push(fn.apply(null, args))\n          continue\n        } else if(fn.value instanceof CustomFunc) { // 内置函数\n          fn.value.updateScope(args)\n          stack.push(fn.value.invokeBody())\n        }\n        break\n      }\n      case INSTR_FUNCDEF: { // 函数定义\n        if (typeof value !== 'string') {\n          stack.push(value); // 函数体\n          continue\n        }\n        if (stack.length === 0) return\n        const _scope = merge(Object.create(null), scope); // 作用域\n  \n        // done: 嵌套函数区分, 挂载到当前_scope上\n        _scope[value] = new Instruction<CustomFunc>(INSTR_EXECUTBODY, new CustomFunc(stack.pop(), values, _scope, ceval))\n  \n        Object.assign(scope, _scope)\n        break\n      }\n      default: {\n        const _val = Symbol('_init') // 值可能就是undefined，做区分\n        let val = _val\n        try {\n          val = item.value\n        } catch (e) {\n          // item = undefined | null | false | true ....\n        }\n        if (val !== _val) {\n          stack.push(val)\n        }\n      }\n    }\n  }\n  return statis ? stack : stack[0];\n}\n\nfunction specifyAttr<T>(value: string, [customValues, defaultValues], shouldCustom = false): T {\n  let fn: T\n  if(shouldCustom && hasAttribute(customValues, value)) {\n    fn = customValues[value] as T;\n  } else {\n    fn = defaultValues[value] as T;\n  }\n  return fn\n};\n\n// class Data {\n//   constructor()\n// }\n\nclass CustomFunc {\n  args: string[];\n\n  constructor(public func: Instruction<any>[], public values: Record<string, any>, public _scope: Record<string, any>, public ceval: Ceval) {\n    const args = this.func.splice(0, func.length - 1)\n    this.args = calculation(args, mapToObject(args, (k) => k), ceval, true)\n    this._scope = merge(mapToObject(args), _scope);\n  }\n\n  updateScope = (scope: any[]) => {\n    // 假设 Object attribute 是不保证顺序的。\n    this.args.forEach((key, index) => {\n      if(hasAttribute(this._scope, key)) {\n        this._scope[key] = scope[index]\n      }\n    });\n  }\n\n  invokeBody = () => {\n    return calculation(this.func, this.values, this.ceval, false, this._scope)\n  }\n}\n","import { getTime } from './index';\n\nconst [date, time] = getTime()\n\nexport default {\n  now: Date.now(),\n  date,\n  time,\n}","import Parser from './parser';\nimport Ceval from './index';\nimport Token from './token';\nimport TokenStream from './token-stream';\nimport Instruction from './instruction';\n\nexport type TypeParser = InstanceType<typeof Parser>\n\nexport type TypeCeval = InstanceType<typeof Ceval>\n\nexport type TypeToken = InstanceType<typeof Token>\n\nexport type TypeTokenStream = InstanceType<typeof TokenStream>\n\nexport type TypeInstruction = Instruction<any>\n\nexport type KeyOfValType<T extends object> = T[keyof T];\n\nexport class CevalOptions {\n  /**\n   * @desc 允许使用运算符\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  endableOperators?: boolean = true;\n\n  /**\n   * @desc 允许启用多位进制Number\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  endableBitNumber?: boolean = true;\n\n  /**\n   * @desc 允许访问成员\n   * @requires false\n   * @todo TODO: 做控制\n   * @type {boolean}\n   */\n  allowMemberAccess?: boolean = true;\n\n  /**\n   * @desc 允许默认放大计算，以处理四则运算的结果 e.g 0.1+0.2 !== 0.3  || 1.0-0.9 !== 0.1\n   * 在超出边界的情况下（ta > Number.MAX_SAFE_INTEGER || ta < Number.MIN_SAFE_INTEGER）会不做处理，还原四则运算\n   * @requires false \n   * @type {boolean}\n   */\n  allowHandleNumberPrecision?: boolean = true;\n\n  /**\n   * @desc 默认不允许操作符被 presetValue 覆盖\n   * @see 某些情况下开发者想制定更加精确的计算,例如BigInt,那么就在根据operatorMap声明presetValue={'+':Function}\n   * @requires false\n   * @type {boolean}\n   * @memberof CevalOptions\n   */\n  allowOperatorsCovered?: boolean = false;\n  \n  /**\n   * @desc 当没有返回值或为undefined时触发默认返回值\n   * @requires false\n   * @todo done\n   * @type {any}\n   */\n  defaultReturnValues?: any = '' // done\n}","import Parser from './parser';\nimport systemMap, { TypeUnary, TypeBinary, TypeTernary, TypeConst, TypeFunction, operatorMap } from './systemMap';\nimport TokenStream from './token-stream';\nimport calculation from './calculation';\nimport presetVariable from './utils/presetVariable';\nimport { merge } from './utils/index';\nimport { CevalOptions, TypeInstruction } from './interface';\n\nexport default class Ceval {\n  unaryOps: TypeUnary;\n\n  binaryOps: TypeBinary;\n\n  ternaryOps: TypeTernary;\n\n  consts: TypeConst;\n\n  functions: TypeFunction;\n\n  /**\n   * 操作符映射表，可做在presetValues覆盖运算\n   */\n  operatorMap = operatorMap;\n\n  private currentValues: Record<string, any> = { ...presetVariable};\n\n  constructor(private options: Readonly<CevalOptions> = {}) {\n    Object.assign(this, systemMap);\n    merge(this.options, new CevalOptions())\n  }\n\n  /**\n   * 查询支持的操作符方法名称, 可做覆盖\n   * @param ops 操作符\n   * @memberof Ceval\n   */\n  getSupportOperationMap = (ops: string): null | Function => {\n    return Object.prototype.hasOwnProperty.call(operatorMap, ops) ? operatorMap[ops] : null\n  }\n\n  /**\n   * 解析字符串，对外暴露方法\n   * @memberof Ceval\n   */\n  parseString = (expression: string, values: Record<string, any> = {}) => {\n    const instr: TypeInstruction[] = [];\n    const isDev = process.env.NODE_ENV !== 'development';\n    let value\n    if(isDev) {\n        Parser.generatorParser(this, new TokenStream(this, expression), instr)\n        value = this.injectValueToCalc(instr, values)\n    } else {\n      try {\n        Parser.generatorParser(this, new TokenStream(this, expression), instr)\n        value = this.injectValueToCalc(instr, values)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    return value\n  }\n\n  /**\n   * 获取当前数据池 预置+外置+内声明\n   * @returns 数据池\n   * @memberof Ceval\n   */\n  getCurrentValues = (): Record<string, any> => ({ ... this.currentValues});\n\n  /**\n   * 传入指令集开始计算\n   * @param {tokens} Instruction[] 指令集\n   * @param {Record<string, any>} [values={}] 数据池\n   * @memberof Ceval\n   */\n  private injectValueToCalc = (tokens: TypeInstruction[], values: Record<string, any> = {}): any => {\n    // @TODO 检查敏感字\n    // @TODO 检查关键字\n    this.updatePresetValues(values);\n    const result = calculation(tokens, this.currentValues, this)\n    return result === undefined ? this.options.defaultReturnValues : result\n  }\n\n  /**\n   * Update PresetValues\n   * @param {values} Record<string, any> 配置\n   * @memberof Ceval\n   */\n  updatePresetValues = (values: Record<string, any>): void => {\n    Object.assign(this.currentValues, values)\n  }\n\n  /**\n   * Update Option\n   * @param {Options} CevalOptions 配置\n   * @memberof Ceval\n   */\n  updateOptions = (Options: Partial<CevalOptions>): void => {\n    Object.assign(this.options, Options)\n  }\n\n  /**\n   * get Options\n   * @memberof Ceval\n   */\n  getOptions = () => {\n    return {...this.options};\n  }\n\n} "],"names":["Instruction","[object Object]","type","value","this","TOKEN_END","TOKEN_COMMA","TOKEN_NAME","TOKEN_SEMICOLON","Token","index","toString","bind","Object","prototype","isObject","obj","call","contains","source","hasOwnProperty","Array","isArray","some","v","indexOf","merge","target","keys","forEach","key","val","filterUndefine","args","one","item","undefined","hasAttribute","name","mapToObject","arr","defaultValue","length","element","push","unique","Error","join","create","someCondition","errMsg","pop","find","d","getReference","keyQueue","scope","values","path","shift","lastKey","TypeError","Reference","destoryed","getDigitLength","num","split","checkBounds","number","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getBaseNum","a","b","baseNum","Math","pow","max","unwantedHandlePercision","isInteger","system","functions","random","min","apply","f","map","x","i","consts","E","PI","true","false","null","NaN","Infinity","Map","binaryOps","+","options","allowHandleNumberPrecision","round","-","*","/","%","^","||","n1","n2","&&","==","!=","!==",">","<",">=","<=","=","variables","[","array","===","in","String","eliminateQuote","str","quoteReg","test","result","exec","ternaryOps","?","cond","yep","nope","unaryOps","!","~","++","--","typeof","_typeof","match","toLowerCase","return","sin","cos","tan","syntaxOperator",":",".","defineProperty","get","excludeOperator","operatorMap","assign","mapVal","data","object","cb","maps","includes","BLACK_LIST_OPERATORS","supportOperator","from","Set","concat","filter","op","sort","whitespaceReg","booleanReg","commentReg","stringReg","stringGreedyReg","number2bitReg","number8bitReg","number010bitReg","number10bitReg","number16bitReg","numberEbitReg","variableReg","operatorReg","RegExp","r","unaryMapReg","unarySymbolMapReg","constsMapReg","k","execFactoryReg","reg","expr","lastIndex","isUnaryOpeator","Parser","ceval","tokens","exprInstr","len","expression","parseExpression","current","nextToken","next","matchToken","accept","line","column","getCoordinates","printLog","console","error","savedCurrent","savedNextToken","temporarySaved","restore","instr","parseMultipleEvaluation","exp","parseAssignmentExpression","parseConditionalExpression","ident","parseOrExpression","trueBranch","falseBranch","expect","parseAndExpression","branch","parseBitwiseOrExpression","parseBitwiseAndExpression","parseEqualExpression","parseCompareExpression","parseInOrAtExpression","parseBitwiseMoveExpression","parseAddOrSubExpression","parseMulOrDivExpression","parseUnaryExpression","parseField","parseOuterFunctionCallExpression","parseMemberAccessExpression","parseArguments","count","refPath","currentItem","getOptions","allowMemberAccess","parseArrayLiteralDeclaration","parseObjectLiteralDeclaration","identifier","parseFunctionDefinedDeclaration","expreInstr","funcName","parseFunctionBodyExpression","SyntaxError","msg","tip","c","log","inspectParseEnd","parser","jsWord","abstract","arguments","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","eval","export","extends","final","finally","float","for","function","goto","if","implements","import","instanceof","int","interface","let","long","native","new","package","private","protected","public","short","static","super","switch","synchronized","throw","throws","transient","try","var","void","volatile","while","with","yield","jsAttr","Date","isFinite","isNaN","isPrototypeOf","valueOf","TokenStream","offset","start","pos","substr","newToken","isWhiteSpace","isComment","isNumber","isString","isBoolean","isParenthesis","isComma","isOperator","isSemicolon","isConst","isVariable","isFunctionDefined","isName","parseError","charAt","savedPosition","matchWS","getSomeCode","prefixCm","matchResult","word","getFirstWord","checkNextAccessGrammar","first","bit","n","endableBitNumber","base","times","parseFloat","parseInt","replace","matchString","strContent","surplusStr","substring","isPalindrome","constKey","endableOperators","ErrorType","coords","calculation","statis","stack","n3","fn","splice","specifyAttr","allowOperatorsCovered","setValue","destory","nextItem","ref","getValue","warn","CustomFunc","updateScope","invokeBody","_scope","_val","Symbol","e","customValues","defaultValues","shouldCustom","func","date","time","o","now","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","t","getTime","CevalOptions","presetVariable","ops","process","env","NODE_ENV","generatorParser","injectValueToCalc","currentValues","updatePresetValues","defaultReturnValues","Options","systemMap"],"mappings":"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"}